{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { getControlAsyncValidators, getControlValidators, mergeValidators } from '../validators';\nimport { BuiltInControlValueAccessor } from './control_value_accessor';\nimport { DefaultValueAccessor } from './default_value_accessor';\nimport { ngModelWarning } from './reactive_errors';\nconst ngDevMode = true;\nexport function controlPath(name, parent) {\n  return [...parent.path, name];\n}\n/**\n * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both\n * instances. This function is typically invoked when form directive is being initialized.\n *\n * @param control Form control instance that should be linked.\n * @param dir Directive that should be linked with a given control.\n */\n\nexport function setUpControl(control, dir) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!control) _throwError(dir, 'Cannot find control with');\n    if (!dir.valueAccessor) _throwError(dir, 'No value accessor for form control with');\n  }\n\n  setUpValidators(control, dir);\n  dir.valueAccessor.writeValue(control.value);\n  setUpViewChangePipeline(control, dir);\n  setUpModelChangePipeline(control, dir);\n  setUpBlurPipeline(control, dir);\n  setUpDisabledChangeHandler(control, dir);\n}\n/**\n * Reverts configuration performed by the `setUpControl` control function.\n * Effectively disconnects form control with a given form directive.\n * This function is typically invoked when corresponding form directive is being destroyed.\n *\n * @param control Form control which should be cleaned up.\n * @param dir Directive that should be disconnected from a given control.\n * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should\n *     contain asserts to verify that it's not called once directive is destroyed. We need this flag\n *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.\n */\n\nexport function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {\n  const noop = () => {\n    if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      _noControlError(dir);\n    }\n  }; // The `valueAccessor` field is typically defined on FromControl and FormControlName directive\n  // instances and there is a logic in `selectValueAccessor` function that throws if it's not the\n  // case. We still check the presence of `valueAccessor` before invoking its methods to make sure\n  // that cleanup works correctly if app code or tests are setup to ignore the error thrown from\n  // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.\n\n\n  if (dir.valueAccessor) {\n    dir.valueAccessor.registerOnChange(noop);\n    dir.valueAccessor.registerOnTouched(noop);\n  }\n\n  cleanUpValidators(control, dir);\n\n  if (control) {\n    dir._invokeOnDestroyCallbacks();\n\n    control._registerOnCollectionChange(() => {});\n  }\n}\n\nfunction registerOnValidatorChange(validators, onChange) {\n  validators.forEach(validator => {\n    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);\n  });\n}\n/**\n * Sets up disabled change handler function on a given form control if ControlValueAccessor\n * associated with a given directive instance supports the `setDisabledState` call.\n *\n * @param control Form control where disabled change handler should be setup.\n * @param dir Corresponding directive instance associated with this control.\n */\n\n\nexport function setUpDisabledChangeHandler(control, dir) {\n  if (dir.valueAccessor.setDisabledState) {\n    const onDisabledChange = isDisabled => {\n      dir.valueAccessor.setDisabledState(isDisabled);\n    };\n\n    control.registerOnDisabledChange(onDisabledChange); // Register a callback function to cleanup disabled change handler\n    // from a control instance when a directive is destroyed.\n\n    dir._registerOnDestroy(() => {\n      control._unregisterOnDisabledChange(onDisabledChange);\n    });\n  }\n}\n/**\n * Sets up sync and async directive validators on provided form control.\n * This function merges validators from the directive into the validators of the control.\n *\n * @param control Form control where directive validators should be setup.\n * @param dir Directive instance that contains validators to be setup.\n */\n\nexport function setUpValidators(control, dir) {\n  const validators = getControlValidators(control);\n\n  if (dir.validator !== null) {\n    control.setValidators(mergeValidators(validators, dir.validator));\n  } else if (typeof validators === 'function') {\n    // If sync validators are represented by a single validator function, we force the\n    // `Validators.compose` call to happen by executing the `setValidators` function with\n    // an array that contains that function. We need this to avoid possible discrepancies in\n    // validators behavior, so sync validators are always processed by the `Validators.compose`.\n    // Note: we should consider moving this logic inside the `setValidators` function itself, so we\n    // have consistent behavior on AbstractControl API level. The same applies to the async\n    // validators logic below.\n    control.setValidators([validators]);\n  }\n\n  const asyncValidators = getControlAsyncValidators(control);\n\n  if (dir.asyncValidator !== null) {\n    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));\n  } else if (typeof asyncValidators === 'function') {\n    control.setAsyncValidators([asyncValidators]);\n  } // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n\n\n  const onValidatorChange = () => control.updateValueAndValidity();\n\n  registerOnValidatorChange(dir._rawValidators, onValidatorChange);\n  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);\n}\n/**\n * Cleans up sync and async directive validators on provided form control.\n * This function reverts the setup performed by the `setUpValidators` function, i.e.\n * removes directive-specific validators from a given control instance.\n *\n * @param control Form control from where directive validators should be removed.\n * @param dir Directive instance that contains validators to be removed.\n * @returns true if a control was updated as a result of this action.\n */\n\nexport function cleanUpValidators(control, dir) {\n  let isControlUpdated = false;\n\n  if (control !== null) {\n    if (dir.validator !== null) {\n      const validators = getControlValidators(control);\n\n      if (Array.isArray(validators) && validators.length > 0) {\n        // Filter out directive validator function.\n        const updatedValidators = validators.filter(validator => validator !== dir.validator);\n\n        if (updatedValidators.length !== validators.length) {\n          isControlUpdated = true;\n          control.setValidators(updatedValidators);\n        }\n      }\n    }\n\n    if (dir.asyncValidator !== null) {\n      const asyncValidators = getControlAsyncValidators(control);\n\n      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n        // Filter out directive async validator function.\n        const updatedAsyncValidators = asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator);\n\n        if (updatedAsyncValidators.length !== asyncValidators.length) {\n          isControlUpdated = true;\n          control.setAsyncValidators(updatedAsyncValidators);\n        }\n      }\n    }\n  } // Clear onValidatorChange callbacks by providing a noop function.\n\n\n  const noop = () => {};\n\n  registerOnValidatorChange(dir._rawValidators, noop);\n  registerOnValidatorChange(dir._rawAsyncValidators, noop);\n  return isControlUpdated;\n}\n\nfunction setUpViewChangePipeline(control, dir) {\n  dir.valueAccessor.registerOnChange(newValue => {\n    control._pendingValue = newValue;\n    control._pendingChange = true;\n    control._pendingDirty = true;\n    if (control.updateOn === 'change') updateControl(control, dir);\n  });\n}\n\nfunction setUpBlurPipeline(control, dir) {\n  dir.valueAccessor.registerOnTouched(() => {\n    control._pendingTouched = true;\n    if (control.updateOn === 'blur' && control._pendingChange) updateControl(control, dir);\n    if (control.updateOn !== 'submit') control.markAsTouched();\n  });\n}\n\nfunction updateControl(control, dir) {\n  if (control._pendingDirty) control.markAsDirty();\n  control.setValue(control._pendingValue, {\n    emitModelToViewChange: false\n  });\n  dir.viewToModelUpdate(control._pendingValue);\n  control._pendingChange = false;\n}\n\nfunction setUpModelChangePipeline(control, dir) {\n  const onChange = (newValue, emitModelEvent) => {\n    // control -> view\n    dir.valueAccessor.writeValue(newValue); // control -> ngModel\n\n    if (emitModelEvent) dir.viewToModelUpdate(newValue);\n  };\n\n  control.registerOnChange(onChange); // Register a callback function to cleanup onChange handler\n  // from a control instance when a directive is destroyed.\n\n  dir._registerOnDestroy(() => {\n    control._unregisterOnChange(onChange);\n  });\n}\n/**\n * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators\n * present in the view.\n *\n * @param control FormGroup or FormArray instance that should be linked.\n * @param dir Directive that provides view validators.\n */\n\n\nexport function setUpFormContainer(control, dir) {\n  if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Cannot find control with');\n  setUpValidators(control, dir);\n}\n/**\n * Reverts the setup performed by the `setUpFormContainer` function.\n *\n * @param control FormGroup or FormArray instance that should be cleaned up.\n * @param dir Directive that provided view validators.\n * @returns true if a control was updated as a result of this action.\n */\n\nexport function cleanUpFormContainer(control, dir) {\n  return cleanUpValidators(control, dir);\n}\n\nfunction _noControlError(dir) {\n  return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n}\n\nfunction _throwError(dir, message) {\n  let messageEnd;\n\n  if (dir.path.length > 1) {\n    messageEnd = `path: '${dir.path.join(' -> ')}'`;\n  } else if (dir.path[0]) {\n    messageEnd = `name: '${dir.path}'`;\n  } else {\n    messageEnd = 'unspecified name attribute';\n  }\n\n  throw new Error(`${message} ${messageEnd}`);\n}\n\nexport function isPropertyUpdated(changes, viewModel) {\n  if (!changes.hasOwnProperty('model')) return false;\n  const change = changes['model'];\n  if (change.isFirstChange()) return true;\n  return !Object.is(viewModel, change.currentValue);\n}\nexport function isBuiltInAccessor(valueAccessor) {\n  // Check if a given value accessor is an instance of a class that directly extends\n  // `BuiltInControlValueAccessor` one.\n  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;\n}\nexport function syncPendingControls(form, directives) {\n  form._syncPendingControls();\n\n  directives.forEach(dir => {\n    const control = dir.control;\n\n    if (control.updateOn === 'submit' && control._pendingChange) {\n      dir.viewToModelUpdate(control._pendingValue);\n      control._pendingChange = false;\n    }\n  });\n} // TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\n\nexport function selectValueAccessor(dir, valueAccessors) {\n  if (!valueAccessors) return null;\n  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'Value accessor was not provided as an array for form control with');\n  let defaultAccessor = undefined;\n  let builtinAccessor = undefined;\n  let customAccessor = undefined;\n  valueAccessors.forEach(v => {\n    if (v.constructor === DefaultValueAccessor) {\n      defaultAccessor = v;\n    } else if (isBuiltInAccessor(v)) {\n      if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one built-in value accessor matches form control with');\n      builtinAccessor = v;\n    } else {\n      if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode)) _throwError(dir, 'More than one custom value accessor matches form control with');\n      customAccessor = v;\n    }\n  });\n  if (customAccessor) return customAccessor;\n  if (builtinAccessor) return builtinAccessor;\n  if (defaultAccessor) return defaultAccessor;\n\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    _throwError(dir, 'No valid value accessor for form control with');\n  }\n\n  return null;\n}\nexport function removeListItem(list, el) {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n} // TODO(kara): remove after deprecation period\n\nexport function _ngModelWarning(name, type, instance, warningConfig) {\n  if (warningConfig === 'never') return;\n\n  if ((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce || warningConfig === 'always' && !instance._ngModelWarningSent) {\n    console.warn(ngModelWarning(name));\n    type._ngModelWarningSentOnce = true;\n    instance._ngModelWarningSent = true;\n  }\n}","map":{"version":3,"sources":["/home/nig/angular-typed-forms-ex-nwhadc/src/forms/src/directives/shared.ts"],"names":["getControlAsyncValidators","getControlValidators","mergeValidators","BuiltInControlValueAccessor","DefaultValueAccessor","ngModelWarning","ngDevMode","controlPath","name","parent","path","setUpControl","control","dir","_throwError","valueAccessor","setUpValidators","writeValue","value","setUpViewChangePipeline","setUpModelChangePipeline","setUpBlurPipeline","setUpDisabledChangeHandler","cleanUpControl","validateControlPresenceOnChange","noop","_noControlError","registerOnChange","registerOnTouched","cleanUpValidators","_invokeOnDestroyCallbacks","_registerOnCollectionChange","registerOnValidatorChange","validators","onChange","forEach","validator","setDisabledState","onDisabledChange","isDisabled","registerOnDisabledChange","_registerOnDestroy","_unregisterOnDisabledChange","setValidators","asyncValidators","asyncValidator","setAsyncValidators","onValidatorChange","updateValueAndValidity","_rawValidators","_rawAsyncValidators","isControlUpdated","Array","isArray","length","updatedValidators","filter","updatedAsyncValidators","newValue","_pendingValue","_pendingChange","_pendingDirty","updateOn","updateControl","_pendingTouched","markAsTouched","markAsDirty","setValue","emitModelToViewChange","viewToModelUpdate","emitModelEvent","_unregisterOnChange","setUpFormContainer","cleanUpFormContainer","message","messageEnd","join","Error","isPropertyUpdated","changes","viewModel","hasOwnProperty","change","isFirstChange","Object","is","currentValue","isBuiltInAccessor","getPrototypeOf","constructor","syncPendingControls","form","directives","_syncPendingControls","selectValueAccessor","valueAccessors","defaultAccessor","undefined","builtinAccessor","customAccessor","v","removeListItem","list","el","index","indexOf","splice","_ngModelWarning","type","instance","warningConfig","_ngModelWarningSentOnce","_ngModelWarningSent","console","warn"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { getControlAsyncValidators, getControlValidators, mergeValidators, } from '../validators';\nimport { BuiltInControlValueAccessor, } from './control_value_accessor';\nimport { DefaultValueAccessor } from './default_value_accessor';\nimport { ngModelWarning } from './reactive_errors';\nconst ngDevMode = true;\nexport function controlPath(name, parent) {\n    return [...parent.path, name];\n}\n/**\n * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both\n * instances. This function is typically invoked when form directive is being initialized.\n *\n * @param control Form control instance that should be linked.\n * @param dir Directive that should be linked with a given control.\n */\nexport function setUpControl(control, dir) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!control)\n            _throwError(dir, 'Cannot find control with');\n        if (!dir.valueAccessor)\n            _throwError(dir, 'No value accessor for form control with');\n    }\n    setUpValidators(control, dir);\n    dir.valueAccessor.writeValue(control.value);\n    setUpViewChangePipeline(control, dir);\n    setUpModelChangePipeline(control, dir);\n    setUpBlurPipeline(control, dir);\n    setUpDisabledChangeHandler(control, dir);\n}\n/**\n * Reverts configuration performed by the `setUpControl` control function.\n * Effectively disconnects form control with a given form directive.\n * This function is typically invoked when corresponding form directive is being destroyed.\n *\n * @param control Form control which should be cleaned up.\n * @param dir Directive that should be disconnected from a given control.\n * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should\n *     contain asserts to verify that it's not called once directive is destroyed. We need this flag\n *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.\n */\nexport function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {\n    const noop = () => {\n        if (validateControlPresenceOnChange &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            _noControlError(dir);\n        }\n    };\n    // The `valueAccessor` field is typically defined on FromControl and FormControlName directive\n    // instances and there is a logic in `selectValueAccessor` function that throws if it's not the\n    // case. We still check the presence of `valueAccessor` before invoking its methods to make sure\n    // that cleanup works correctly if app code or tests are setup to ignore the error thrown from\n    // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.\n    if (dir.valueAccessor) {\n        dir.valueAccessor.registerOnChange(noop);\n        dir.valueAccessor.registerOnTouched(noop);\n    }\n    cleanUpValidators(control, dir);\n    if (control) {\n        dir._invokeOnDestroyCallbacks();\n        control._registerOnCollectionChange(() => { });\n    }\n}\nfunction registerOnValidatorChange(validators, onChange) {\n    validators.forEach((validator) => {\n        if (validator.registerOnValidatorChange)\n            validator.registerOnValidatorChange(onChange);\n    });\n}\n/**\n * Sets up disabled change handler function on a given form control if ControlValueAccessor\n * associated with a given directive instance supports the `setDisabledState` call.\n *\n * @param control Form control where disabled change handler should be setup.\n * @param dir Corresponding directive instance associated with this control.\n */\nexport function setUpDisabledChangeHandler(control, dir) {\n    if (dir.valueAccessor.setDisabledState) {\n        const onDisabledChange = (isDisabled) => {\n            dir.valueAccessor.setDisabledState(isDisabled);\n        };\n        control.registerOnDisabledChange(onDisabledChange);\n        // Register a callback function to cleanup disabled change handler\n        // from a control instance when a directive is destroyed.\n        dir._registerOnDestroy(() => {\n            control._unregisterOnDisabledChange(onDisabledChange);\n        });\n    }\n}\n/**\n * Sets up sync and async directive validators on provided form control.\n * This function merges validators from the directive into the validators of the control.\n *\n * @param control Form control where directive validators should be setup.\n * @param dir Directive instance that contains validators to be setup.\n */\nexport function setUpValidators(control, dir) {\n    const validators = getControlValidators(control);\n    if (dir.validator !== null) {\n        control.setValidators(mergeValidators(validators, dir.validator));\n    }\n    else if (typeof validators === 'function') {\n        // If sync validators are represented by a single validator function, we force the\n        // `Validators.compose` call to happen by executing the `setValidators` function with\n        // an array that contains that function. We need this to avoid possible discrepancies in\n        // validators behavior, so sync validators are always processed by the `Validators.compose`.\n        // Note: we should consider moving this logic inside the `setValidators` function itself, so we\n        // have consistent behavior on AbstractControl API level. The same applies to the async\n        // validators logic below.\n        control.setValidators([validators]);\n    }\n    const asyncValidators = getControlAsyncValidators(control);\n    if (dir.asyncValidator !== null) {\n        control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));\n    }\n    else if (typeof asyncValidators === 'function') {\n        control.setAsyncValidators([asyncValidators]);\n    }\n    // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n    const onValidatorChange = () => control.updateValueAndValidity();\n    registerOnValidatorChange(dir._rawValidators, onValidatorChange);\n    registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);\n}\n/**\n * Cleans up sync and async directive validators on provided form control.\n * This function reverts the setup performed by the `setUpValidators` function, i.e.\n * removes directive-specific validators from a given control instance.\n *\n * @param control Form control from where directive validators should be removed.\n * @param dir Directive instance that contains validators to be removed.\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpValidators(control, dir) {\n    let isControlUpdated = false;\n    if (control !== null) {\n        if (dir.validator !== null) {\n            const validators = getControlValidators(control);\n            if (Array.isArray(validators) && validators.length > 0) {\n                // Filter out directive validator function.\n                const updatedValidators = validators.filter((validator) => validator !== dir.validator);\n                if (updatedValidators.length !== validators.length) {\n                    isControlUpdated = true;\n                    control.setValidators(updatedValidators);\n                }\n            }\n        }\n        if (dir.asyncValidator !== null) {\n            const asyncValidators = getControlAsyncValidators(control);\n            if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n                // Filter out directive async validator function.\n                const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);\n                if (updatedAsyncValidators.length !== asyncValidators.length) {\n                    isControlUpdated = true;\n                    control.setAsyncValidators(updatedAsyncValidators);\n                }\n            }\n        }\n    }\n    // Clear onValidatorChange callbacks by providing a noop function.\n    const noop = () => { };\n    registerOnValidatorChange(dir._rawValidators, noop);\n    registerOnValidatorChange(dir._rawAsyncValidators, noop);\n    return isControlUpdated;\n}\nfunction setUpViewChangePipeline(control, dir) {\n    dir.valueAccessor.registerOnChange((newValue) => {\n        control._pendingValue = newValue;\n        control._pendingChange = true;\n        control._pendingDirty = true;\n        if (control.updateOn === 'change')\n            updateControl(control, dir);\n    });\n}\nfunction setUpBlurPipeline(control, dir) {\n    dir.valueAccessor.registerOnTouched(() => {\n        control._pendingTouched = true;\n        if (control.updateOn === 'blur' && control._pendingChange)\n            updateControl(control, dir);\n        if (control.updateOn !== 'submit')\n            control.markAsTouched();\n    });\n}\nfunction updateControl(control, dir) {\n    if (control._pendingDirty)\n        control.markAsDirty();\n    control.setValue(control._pendingValue, { emitModelToViewChange: false });\n    dir.viewToModelUpdate(control._pendingValue);\n    control._pendingChange = false;\n}\nfunction setUpModelChangePipeline(control, dir) {\n    const onChange = (newValue, emitModelEvent) => {\n        // control -> view\n        dir.valueAccessor.writeValue(newValue);\n        // control -> ngModel\n        if (emitModelEvent)\n            dir.viewToModelUpdate(newValue);\n    };\n    control.registerOnChange(onChange);\n    // Register a callback function to cleanup onChange handler\n    // from a control instance when a directive is destroyed.\n    dir._registerOnDestroy(() => {\n        control._unregisterOnChange(onChange);\n    });\n}\n/**\n * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators\n * present in the view.\n *\n * @param control FormGroup or FormArray instance that should be linked.\n * @param dir Directive that provides view validators.\n */\nexport function setUpFormContainer(control, dir) {\n    if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'Cannot find control with');\n    setUpValidators(control, dir);\n}\n/**\n * Reverts the setup performed by the `setUpFormContainer` function.\n *\n * @param control FormGroup or FormArray instance that should be cleaned up.\n * @param dir Directive that provided view validators.\n * @returns true if a control was updated as a result of this action.\n */\nexport function cleanUpFormContainer(control, dir) {\n    return cleanUpValidators(control, dir);\n}\nfunction _noControlError(dir) {\n    return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n}\nfunction _throwError(dir, message) {\n    let messageEnd;\n    if (dir.path.length > 1) {\n        messageEnd = `path: '${dir.path.join(' -> ')}'`;\n    }\n    else if (dir.path[0]) {\n        messageEnd = `name: '${dir.path}'`;\n    }\n    else {\n        messageEnd = 'unspecified name attribute';\n    }\n    throw new Error(`${message} ${messageEnd}`);\n}\nexport function isPropertyUpdated(changes, viewModel) {\n    if (!changes.hasOwnProperty('model'))\n        return false;\n    const change = changes['model'];\n    if (change.isFirstChange())\n        return true;\n    return !Object.is(viewModel, change.currentValue);\n}\nexport function isBuiltInAccessor(valueAccessor) {\n    // Check if a given value accessor is an instance of a class that directly extends\n    // `BuiltInControlValueAccessor` one.\n    return (Object.getPrototypeOf(valueAccessor.constructor) ===\n        BuiltInControlValueAccessor);\n}\nexport function syncPendingControls(form, directives) {\n    form._syncPendingControls();\n    directives.forEach((dir) => {\n        const control = dir.control;\n        if (control.updateOn === 'submit' && control._pendingChange) {\n            dir.viewToModelUpdate(control._pendingValue);\n            control._pendingChange = false;\n        }\n    });\n}\n// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\nexport function selectValueAccessor(dir, valueAccessors) {\n    if (!valueAccessors)\n        return null;\n    if (!Array.isArray(valueAccessors) &&\n        (typeof ngDevMode === 'undefined' || ngDevMode))\n        _throwError(dir, 'Value accessor was not provided as an array for form control with');\n    let defaultAccessor = undefined;\n    let builtinAccessor = undefined;\n    let customAccessor = undefined;\n    valueAccessors.forEach((v) => {\n        if (v.constructor === DefaultValueAccessor) {\n            defaultAccessor = v;\n        }\n        else if (isBuiltInAccessor(v)) {\n            if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n                _throwError(dir, 'More than one built-in value accessor matches form control with');\n            builtinAccessor = v;\n        }\n        else {\n            if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))\n                _throwError(dir, 'More than one custom value accessor matches form control with');\n            customAccessor = v;\n        }\n    });\n    if (customAccessor)\n        return customAccessor;\n    if (builtinAccessor)\n        return builtinAccessor;\n    if (defaultAccessor)\n        return defaultAccessor;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _throwError(dir, 'No valid value accessor for form control with');\n    }\n    return null;\n}\nexport function removeListItem(list, el) {\n    const index = list.indexOf(el);\n    if (index > -1)\n        list.splice(index, 1);\n}\n// TODO(kara): remove after deprecation period\nexport function _ngModelWarning(name, type, instance, warningConfig) {\n    if (warningConfig === 'never')\n        return;\n    if (((warningConfig === null || warningConfig === 'once') &&\n        !type._ngModelWarningSentOnce) ||\n        (warningConfig === 'always' && !instance._ngModelWarningSent)) {\n        console.warn(ngModelWarning(name));\n        type._ngModelWarningSentOnce = true;\n        instance._ngModelWarningSent = true;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { EventEmitter } from '@angular/core';\nimport { removeListItem } from './directives/shared';\nimport { addValidators, composeAsyncValidators, composeValidators, hasValidator, removeValidators, toObservable } from './validators';\n/**\n * Reports that a FormControl is valid, meaning that no errors exist in the input value.\n *\n * @see `status`\n */\n\nexport const VALID = 'VALID';\n/**\n * Reports that a FormControl is invalid, meaning that an error exists in the input value.\n *\n * @see `status`\n */\n\nexport const INVALID = 'INVALID';\n/**\n * Reports that a FormControl is pending, meaning that that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see `markAsPending`\n * @see `status`\n */\n\nexport const PENDING = 'PENDING';\n/**\n * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see `markAsDisabled`\n * @see `status`\n */\n\nexport const DISABLED = 'DISABLED';\n\nfunction _find(control, path, delimiter) {\n  if (path == null) return null;\n\n  if (!Array.isArray(path)) {\n    path = path.split(delimiter);\n  }\n\n  if (Array.isArray(path) && path.length === 0) return null; // Not using Array.reduce here due to a Chrome 80 bug\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n\n  let controlToFind = control;\n  path.forEach(name => {\n    if (controlToFind instanceof FormGroup) {\n      controlToFind = controlToFind.controls.hasOwnProperty(name) ? controlToFind.controls[name] : null;\n    } else if (controlToFind instanceof FormArray) {\n      controlToFind = controlToFind.at(name) || null;\n    } else {\n      controlToFind = null;\n    }\n  });\n  return controlToFind;\n}\n/**\n * Gets validators from either an options object or given validators.\n */\n\n\nfunction pickValidators(validatorOrOpts) {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;\n}\n/**\n * Creates validator function by combining provided validators.\n */\n\n\nfunction coerceToValidator(validator) {\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n/**\n * Gets async validators from either an options object or given validators.\n */\n\n\nfunction pickAsyncValidators(asyncValidator, validatorOrOpts) {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;\n}\n/**\n * Creates async validator function by combining provided async validators.\n */\n\n\nfunction coerceToAsyncValidator(asyncValidator) {\n  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;\n}\n\nfunction isOptionsObj(validatorOrOpts) {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === 'object';\n}\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * This class has a main type parameter ValueT which represents the value type of the control.\n * That type can contain partials, due to disabled controls. The optional type parameter RawValueT\n * represents the raw value type (i.e. what the type of `rawValue` would be, or `value` with all\n * controls enabled).\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n * @publicApi\n */\n\n\nexport class AbstractControl {\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validators The function or array of functions that is used to determine the validity of\n   *     this control synchronously.\n   * @param asyncValidators The function or array of functions that is used to determine validity of\n   *     this control asynchronously.\n   */\n  constructor(validators, asyncValidators) {\n    /** @internal */\n    this._pendingDirty = false;\n    /**\n     * Indicates that a control has its own pending asynchronous validation in progress.\n     *\n     * @internal\n     */\n\n    this._hasOwnPendingAsyncValidator = false;\n    /** @internal */\n\n    this._pendingTouched = false;\n    /** @internal */\n\n    this._onCollectionChange = () => {};\n\n    this._parent = null;\n    /**\n     * A control is `pristine` if the user has not yet changed\n     * the value in the UI.\n     *\n     * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n     * Programmatic changes to a control's value do not mark it dirty.\n     */\n\n    this.pristine = true;\n    /**\n     * True if the control is marked as `touched`.\n     *\n     * A control is marked `touched` once the user has triggered\n     * a `blur` event on it.\n     */\n\n    this.touched = false;\n    /** @internal */\n\n    this._onDisabledChange = [];\n    this._rawValidators = validators;\n    this._rawAsyncValidators = asyncValidators;\n    this._composedValidatorFn = coerceToValidator(this._rawValidators);\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);\n  }\n  /**\n   * Returns the function that is used to determine the validity of this control synchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n\n\n  get validator() {\n    return this._composedValidatorFn;\n  }\n\n  set validator(validatorFn) {\n    this._rawValidators = this._composedValidatorFn = validatorFn;\n  }\n  /**\n   * Returns the function that is used to determine the validity of this control asynchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n\n\n  get asyncValidator() {\n    return this._composedAsyncValidatorFn;\n  }\n\n  set asyncValidator(asyncValidatorFn) {\n    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;\n  }\n  /**\n   * The parent control.\n   */\n\n\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n\n\n  get valid() {\n    return this.status === VALID;\n  }\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n\n\n  get invalid() {\n    return this.status === INVALID;\n  }\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n\n\n  get pending() {\n    return this.status == PENDING;\n  }\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n\n\n  get disabled() {\n    return this.status === DISABLED;\n  }\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   */\n\n\n  get enabled() {\n    return this.status !== DISABLED;\n  }\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n\n\n  get dirty() {\n    return !this.pristine;\n  }\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n\n\n  get untouched() {\n    return !this.touched;\n  }\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n\n\n  get updateOn() {\n    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : 'change';\n  }\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing synchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addValidators()` method instead.\n   */\n\n\n  setValidators(validators) {\n    this._rawValidators = validators;\n    this._composedValidatorFn = coerceToValidator(validators);\n  }\n  /**\n   * Sets the asynchronous validators that are active on this control. Calling this\n   * overwrites any existing asynchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addAsyncValidators()` method instead.\n   */\n\n\n  setAsyncValidators(validators) {\n    this._rawAsyncValidators = validators;\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(validators);\n  }\n  /**\n   * Add a synchronous validator or validators to this control, without affecting other validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect. If duplicate validator functions\n   * are present in the `validators` array, only the first instance would be added to a form\n   * control.\n   *\n   * @param validators The new validator function or functions to add to this control.\n   */\n\n\n  addValidators(validators) {\n    this.setValidators(addValidators(validators, this._rawValidators));\n  }\n  /**\n   * Add an asynchronous validator or validators to this control, without affecting other\n   * validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect.\n   *\n   * @param validators The new asynchronous validator function or functions to add to this control.\n   */\n\n\n  addAsyncValidators(validators) {\n    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));\n  }\n  /**\n   * Remove a synchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found,\n   * it is ignored.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The validator or validators to remove.\n   */\n\n\n  removeValidators(validators) {\n    this.setValidators(removeValidators(validators, this._rawValidators));\n  }\n  /**\n   * Remove an asynchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found, it\n   * is ignored.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The asynchronous validator or validators to remove.\n   */\n\n\n  removeAsyncValidators(validators) {\n    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));\n  }\n  /**\n   * Check whether a synchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @param validator The validator to check for presence. Compared by function reference.\n   * @returns Whether the provided validator was found on this control.\n   */\n\n\n  hasValidator(validator) {\n    return hasValidator(this._rawValidators, validator);\n  }\n  /**\n   * Check whether an asynchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @param validator The asynchronous validator to check for presence. Compared by function\n   *     reference.\n   * @returns Whether the provided asynchronous validator was found on this control.\n   */\n\n\n  hasAsyncValidator(validator) {\n    return hasValidator(this._rawAsyncValidators, validator);\n  }\n  /**\n   * Empties out the synchronous validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n\n\n  clearValidators() {\n    this.validator = null;\n  }\n  /**\n   * Empties out the async validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n\n\n  clearAsyncValidators() {\n    this.asyncValidator = null;\n  }\n  /**\n   * Marks the control as `touched`. A control is touched by focus and\n   * blur events that do not change the value.\n   *\n   * @see `markAsUntouched()`\n   * @see `markAsDirty()`\n   * @see `markAsPristine()`\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n\n\n  markAsTouched(opts = {}) {\n    this.touched = true;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(opts);\n    }\n  }\n  /**\n   * Marks the control and all its descendant controls as `touched`.\n   * @see `markAsTouched()`\n   */\n\n\n  markAllAsTouched() {\n    this.markAsTouched({\n      onlySelf: true\n    });\n\n    this._forEachChild(control => control.markAllAsTouched());\n  }\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, also marks all children as `untouched`\n   * and recalculates the `touched` status of all parent controls.\n   *\n   * @see `markAsTouched()`\n   * @see `markAsDirty()`\n   * @see `markAsPristine()`\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after the marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n\n\n  markAsUntouched(opts = {}) {\n    this.touched = false;\n    this._pendingTouched = false;\n\n    this._forEachChild(control => {\n      control.markAsUntouched({\n        onlySelf: true\n      });\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n  /**\n   * Marks the control as `dirty`. A control becomes dirty when\n   * the control's value is changed through the UI; compare `markAsTouched`.\n   *\n   * @see `markAsTouched()`\n   * @see `markAsUntouched()`\n   * @see `markAsPristine()`\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n\n\n  markAsDirty(opts = {}) {\n    this.pristine = false;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(opts);\n    }\n  }\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, marks all children as `pristine`,\n   * and recalculates the `pristine` status of all parent\n   * controls.\n   *\n   * @see `markAsTouched()`\n   * @see `markAsUntouched()`\n   * @see `markAsDirty()`\n   *\n   * @param opts Configuration options that determine how the control emits events after\n   * marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n\n\n  markAsPristine(opts = {}) {\n    this.pristine = true;\n    this._pendingDirty = false;\n\n    this._forEachChild(control => {\n      control.markAsPristine({\n        onlySelf: true\n      });\n    });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n  /**\n   * Marks the control as `pending`.\n   *\n   * A control is pending while the control performs async validation.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates changes and\n   * emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event with the latest status the control is marked pending.\n   * When false, no events are emitted.\n   *\n   */\n\n\n  markAsPending(opts = {}) {\n    this.status = PENDING;\n\n    if (opts.emitEvent !== false) {\n      this.statusChanges.emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(opts);\n    }\n  }\n  /**\n   * Disables the control. This means the control is exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children are also disabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control is disabled.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is disabled.\n   * When false, no events are emitted.\n   */\n\n\n  disable(opts = {}) {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    this.status = DISABLED;\n    this.errors = null;\n\n    this._forEachChild(control => {\n      control.disable(Object.assign(Object.assign({}, opts), {\n        onlySelf: true\n      }));\n    });\n\n    this._updateValue();\n\n    if (opts.emitEvent !== false) {\n      this.valueChanges.emit(this.value);\n      this.statusChanges.emit(this.status);\n    }\n\n    this._updateAncestors(Object.assign(Object.assign({}, opts), {\n      skipPristineCheck\n    }));\n\n    this._onDisabledChange.forEach(changeFn => changeFn(true));\n  }\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n\n\n  enable(opts = {}) {\n    // If parent has been marked artificially dirty we don't want to re-calculate the\n    // parent's dirtiness based on the children.\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n\n    this.status = VALID;\n\n    this._forEachChild(control => {\n      control.enable(Object.assign(Object.assign({}, opts), {\n        onlySelf: true\n      }));\n    });\n\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: opts.emitEvent\n    });\n\n    this._updateAncestors(Object.assign(Object.assign({}, opts), {\n      skipPristineCheck\n    }));\n\n    this._onDisabledChange.forEach(changeFn => changeFn(false));\n  }\n\n  _updateAncestors(opts) {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n\n      if (!opts.skipPristineCheck) {\n        this._parent._updatePristine();\n      }\n\n      this._parent._updateTouched();\n    }\n  }\n  /**\n   * Sets the parent of the control\n   *\n   * @param parent The new parent.\n   */\n\n\n  setParent(parent) {\n    this._parent = parent;\n  }\n  /**\n   * Recalculates the value and validation status of the control.\n   *\n   * By default, it also updates the value and validity of its ancestors.\n   *\n   * @param opts Configuration options determine how the control propagates changes and emits events\n   * after updates and validity checks are applied.\n   * * `onlySelf`: When true, only update this control. When false or not supplied,\n   * update all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is updated.\n   * When false, no events are emitted.\n   */\n\n\n  updateValueAndValidity(opts = {}) {\n    this._setInitialStatus();\n\n    this._updateValue();\n\n    if (this.enabled) {\n      this._cancelExistingSubscription();\n\n      this.errors = this._runValidator();\n      this.status = this._calculateStatus();\n\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(opts.emitEvent);\n      }\n    }\n\n    if (opts.emitEvent !== false) {\n      this.valueChanges.emit(this.value);\n      this.statusChanges.emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n    }\n  }\n  /** @internal */\n\n\n  _updateTreeValidity(opts = {\n    emitEvent: true\n  }) {\n    this._forEachChild(ctrl => ctrl._updateTreeValidity(opts));\n\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: opts.emitEvent\n    });\n  }\n\n  _setInitialStatus() {\n    this.status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n\n  _runValidator() {\n    return this.validator ? this.validator(this) : null;\n  }\n\n  _runAsyncValidator(emitEvent) {\n    if (this.asyncValidator) {\n      this.status = PENDING;\n      this._hasOwnPendingAsyncValidator = true;\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription = obs.subscribe(errors => {\n        this._hasOwnPendingAsyncValidator = false; // This will trigger the recalculation of the validation status, which depends on\n        // the state of the asynchronous validation (whether it is in progress or not). So, it is\n        // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.\n\n        this.setErrors(errors, {\n          emitEvent\n        });\n      });\n    }\n  }\n\n  _cancelExistingSubscription() {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n\n      this._hasOwnPendingAsyncValidator = false;\n    }\n  }\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * @usageNotes\n   *\n   * ### Manually set the errors for a control\n   *\n   * ```\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n\n\n  setErrors(errors, opts = {}) {\n    this.errors = errors;\n\n    this._updateControlsErrors(opts.emitEvent !== false);\n  }\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control. If a string is provided, passing it as a string literal will result in improved type\n   * information. Likewise, if an array is provided, passing it `as const` will cause improved type\n   * information to be available.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings\n   *\n   * ### Retrieve a control in a FormArray\n   *\n   * When accessing an element inside a FormArray, you can use an element index.\n   * For example, to get a `price` control from the first element in an `items` array you can use:\n   *\n   * * `this.form.get('items.0.price');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['items', 0, 'price']);`\n   */\n\n\n  get(path) {\n    return _find(this, path, '.');\n  }\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n\n\n  getError(errorCode, path) {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n\n\n  hasError(errorCode, path) {\n    return !!this.getError(errorCode, path);\n  }\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n\n\n  get root() {\n    let x = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n  /** @internal */\n\n\n  _updateControlsErrors(emitEvent) {\n    this.status = this._calculateStatus();\n\n    if (emitEvent) {\n      this.statusChanges.emit(this.status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n  /** @internal */\n\n\n  _initObservables() {\n    this.valueChanges = new EventEmitter();\n    this.statusChanges = new EventEmitter();\n  }\n\n  _calculateStatus() {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n  /** @internal */\n\n\n  _anyControlsHaveStatus(status) {\n    return this._anyControls(control => control.status === status);\n  }\n  /** @internal */\n\n\n  _anyControlsDirty() {\n    return this._anyControls(control => control.dirty);\n  }\n  /** @internal */\n\n\n  _anyControlsTouched() {\n    return this._anyControls(control => control.touched);\n  }\n  /** @internal */\n\n\n  _updatePristine(opts = {}) {\n    this.pristine = !this._anyControlsDirty();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n  /** @internal */\n\n\n  _updateTouched(opts = {}) {\n    this.touched = this._anyControlsTouched();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n  /** @internal */\n\n\n  _registerOnCollectionChange(fn) {\n    this._onCollectionChange = fn;\n  }\n  /** @internal */\n\n\n  _setUpdateStrategy(opts) {\n    if (isOptionsObj(opts) && opts.updateOn != null) {\n      this._updateOn = opts.updateOn;\n    }\n  }\n  /**\n   * Check to see if parent has been marked artificially dirty.\n   *\n   * @internal\n   */\n\n\n  _parentMarkedDirty(onlySelf) {\n    const parentDirty = this._parent && this._parent.dirty;\n    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();\n  }\n\n}\n\nfunction isFormState(formState) {\n  return typeof formState === 'object' && formState !== null && Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n}\n\nclass FormControlImpl extends AbstractControl {\n  constructor( // formState and defaultValue will only be null if T is nullable\n  formState = null, validatorOrOpts, asyncValidator, defaultValue) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this.defaultValue = null;\n    /** @internal */\n\n    this._onChange = [];\n    /** @internal */\n\n    this._pendingChange = false;\n    /** @internal */\n\n    this._defaultValue = null;\n    this._defaultValue = defaultValue === undefined ? null : defaultValue;\n\n    this._applyFormState(formState);\n\n    this._setUpdateStrategy(validatorOrOpts);\n\n    this._initObservables();\n\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n      // to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n\n    if (isOptionsObj(validatorOrOpts) && validatorOrOpts.initialValueIsDefault) {\n      if (isFormState(formState)) {\n        this.defaultValue = formState.value;\n      } else {\n        this.defaultValue = formState;\n      }\n    }\n  }\n\n  setValue(value, options = {}) {\n    this.value = this._pendingValue = value;\n\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach(changeFn => changeFn(this.value, options.emitViewToModelChange !== false));\n    }\n\n    this.updateValueAndValidity(options);\n  }\n\n  patchValue(value, options = {}) {\n    this.setValue(value, options);\n  }\n\n  reset(formState = this._defaultValue, options = {}) {\n    this._applyFormState(formState);\n\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n  }\n\n  getRawValue() {\n    return this.value;\n  }\n  /** @internal */\n\n\n  _updateValue() {}\n  /** @internal */\n\n\n  _anyControls(condition) {\n    return false;\n  }\n  /** @internal */\n\n\n  _allControlsDisabled() {\n    return this.disabled;\n  }\n\n  registerOnChange(fn) {\n    this._onChange.push(fn);\n  }\n  /**\n   * Internal function to unregister a change events listener.\n   * @internal\n   */\n\n\n  _unregisterOnChange(fn) {\n    removeListItem(this._onChange, fn);\n  }\n\n  registerOnDisabledChange(fn) {\n    this._onDisabledChange.push(fn);\n  }\n  /** @internal */\n\n\n  _unregisterOnDisabledChange(fn) {\n    removeListItem(this._onDisabledChange, fn);\n  }\n  /** @internal */\n\n\n  _forEachChild(cb) {}\n  /** @internal */\n\n\n  _syncPendingControls() {\n    if (this.updateOn === 'submit') {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {\n          onlySelf: true,\n          emitModelToViewChange: false\n        });\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /** @internal */\n\n\n  _applyFormState(formState) {\n    if (isFormState(formState)) {\n      this.value = this._pendingValue = formState.value;\n      formState.disabled ? this.disable({\n        onlySelf: true,\n        emitEvent: false\n      }) : this.enable({\n        onlySelf: true,\n        emitEvent: false\n      });\n    } else {\n      this.value = this._pendingValue = formState;\n    }\n  }\n\n} // The constructor for FormControl is decoupled from its implementation.\n// This allows us to provide multiple constructor signatures.\n\n\nexport const FormControl = FormControlImpl;\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormArray`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * `FormGroup` accepts an optional type parameter `CtrlT`, which is an object type with inner\n * control types as values.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * ### Using a FormGroup with optional controls\n *\n * It is possible to have optional controls in a FormGroup. An optional control can be removed later\n * using `removeControl`, and can be omitted when calling `reset`. Optional controls must be\n * declared optional in the group's type.\n *\n * ```ts\n * const c = new FormGroup<{one?: FormControl<string>}>({\n *   one: new FormControl('')\n * });\n * ```\n *\n * Notice that `c.value.one` has type `string|null|undefined`. This is because calling `c.reset({})`\n * without providing the optional key `one` will cause it to become `null`.\n *\n * @publicApi\n */\n\nexport class FormGroup extends AbstractControl {\n  /**\n   * Creates a new `FormGroup` instance.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this.controls = controls;\n\n    this._initObservables();\n\n    this._setUpdateStrategy(validatorOrOpts);\n\n    this._setUpControls();\n\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,\n      // so we set `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n  }\n  /**\n   * Registers a control with the group's list of controls. In a strongly-typed group, the control\n   * must be in the group's type (possibly as an optional key).\n   *\n   * This method does not update the value or validity of the control.\n   * Use {@link FormGroup#addControl addControl} instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n\n\n  registerControl(name, control) {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n\n    control._registerOnCollectionChange(this._onCollectionChange);\n\n    return control;\n  }\n  /**\n   * Add a control to this group. In a strongly-typed group, the control must be in the group's type\n   * (possibly as an optional key).\n   *\n   * If a control with a given name already exists, it would *not* be replaced with a new one.\n   * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}\n   * method instead. This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   * @param options Specifies whether this FormGroup instance should emit events after a new\n   *     control is added.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * added. When false, no events are emitted.\n   */\n\n\n  addControl(name, control, options = {}) {\n    this.registerControl(name, control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n\n    this._onCollectionChange();\n  }\n  /**\n   * Remove a control from this group. In a strongly-typed group, required controls cannot be\n   * removed.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to remove from the collection\n   * @param options Specifies whether this FormGroup instance should emit events after a\n   *     control is removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * removed. When false, no events are emitted.\n   */\n\n\n  removeControl(name, options = {}) {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete this.controls[name];\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n\n    this._onCollectionChange();\n  }\n  /**\n   * Replace an existing control. In a strongly-typed group, the control must be in the group's type\n   * (possibly as an optional key).\n   *\n   * If a control with a given name does not exist in this `FormGroup`, it will be added.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   * @param options Specifies whether this FormGroup instance should emit events after an\n   *     existing control is replaced.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * replaced with a new one. When false, no events are emitted.\n   */\n\n\n  setControl(name, control, options = {}) {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete this.controls[name];\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n\n    this._onCollectionChange();\n  }\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use {@link AbstractControl#get get} instead.\n   *\n   * @param controlName The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n\n\n  contains(controlName) {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you exclude a value of a control that does exist.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n\n\n  setValue(value, options = {}) {\n    this._checkAllValuesPresent(value);\n\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n\n      this.controls[name].setValue(value[name], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control value\n   * is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n\n\n  patchValue(value, options = {}) {\n    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n    // `patchValue` can be called recursively and inner data structures might have these values, so\n    // we just ignore such cases when a field containing FormGroup instance receives `null` or\n    // `undefined` as a value.\n    if (value == null\n    /* both `null` and `undefined` */\n    ) return;\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(\n        /* Guaranteed to be present, due to the outer forEach. */\n        value[name], {\n          onlySelf: true,\n          emitEvent: options.emitEvent\n        });\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n   * the value of all descendants to their default values, or null if no defaults were provided.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param value Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(form.value);  // {last: 'last'}\n   * console.log(form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n\n\n  reset(value = {}, options = {}) {\n    this._forEachChild((control, name) => {\n      control.reset(value[name], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n\n    this._updatePristine(options);\n\n    this._updateTouched(options);\n\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   */\n\n\n  getRawValue() {\n    return this._reduceChildren({}, (acc, control, name) => {\n      acc[name] = control.getRawValue();\n      return acc;\n    });\n  }\n  /** @internal */\n\n\n  _syncPendingControls() {\n    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n\n    if (subtreeUpdated) this.updateValueAndValidity({\n      onlySelf: true\n    });\n    return subtreeUpdated;\n  }\n  /** @internal */\n\n\n  _throwIfControlMissing(name) {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n  /** @internal */\n\n\n  _forEachChild(cb) {\n    Object.keys(this.controls).forEach(key => {\n      // The list of controls can change (for ex. controls might be removed) while the loop\n      // is running (as a result of invoking Forms API in `valueChanges` subscription), so we\n      // have to null check before invoking the callback.\n      const control = this.controls[key];\n      control && cb(control, key);\n    });\n  }\n  /** @internal */\n\n\n  _setUpControls() {\n    this._forEachChild(control => {\n      control.setParent(this);\n\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n  /** @internal */\n\n\n  _updateValue() {\n    this.value = this._reduceValue();\n  }\n  /** @internal */\n\n\n  _anyControls(condition) {\n    for (const controlName of Object.keys(this.controls)) {\n      const control = this.controls[controlName];\n\n      if (this.contains(controlName) && condition(control)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /** @internal */\n\n\n  _reduceValue() {\n    let acc = {};\n    return this._reduceChildren(acc, (acc, control, name) => {\n      if (control.enabled || this.disabled) {\n        acc[name] = control.value;\n      }\n\n      return acc;\n    });\n  }\n  /** @internal */\n\n\n  _reduceChildren(initValue, fn) {\n    let res = initValue;\n\n    this._forEachChild((control, name) => {\n      res = fn(res, control, name);\n    });\n\n    return res;\n  }\n  /** @internal */\n\n\n  _allControlsDisabled() {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n  /** @internal */\n\n\n  _checkAllValuesPresent(value) {\n    this._forEachChild((control, name) => {\n      if (value[name] === undefined) {\n        throw new Error(`Must supply a value for form control with name: '${name}'.`);\n      }\n    });\n  }\n\n}\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormGroup`.\n *\n * `FormArray` accepts an optional type parameter `CtrlT`, which should be an array containing the\n * types of inner controls. If an untyped `FormArray` is desired, `any[]` should be explicitly\n * specified.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n * @publicApi\n */\n\nexport class FormArray extends AbstractControl {\n  /**\n   * Creates a new `FormArray` instance.\n   *\n   * @param controls An array of child controls. Each child control is given an index\n   * where it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this.controls = controls;\n\n    this._initObservables();\n\n    this._setUpdateStrategy(validatorOrOpts);\n\n    this._setUpControls();\n\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set\n      // `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n  }\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control\n   */\n\n\n  at(index) {\n    return this.controls[index];\n  }\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   *\n   * @param control Form control to be inserted\n   * @param options Specifies whether this FormArray instance should emit events after a new\n   *     control is added.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * inserted. When false, no events are emitted.\n   */\n\n\n  push(control, options = {}) {\n    this.controls.push(control);\n\n    this._registerControl(control);\n\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n\n    this._onCollectionChange();\n  }\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control\n   * @param control Form control to be inserted\n   * @param options Specifies whether this FormArray instance should emit events after a new\n   *     control is inserted.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * inserted. When false, no events are emitted.\n   */\n\n\n  insert(index, control, options = {}) {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  /**\n   * Remove the control at the given `index` in the array.\n   *\n   * @param index Index in the array to remove the control\n   * @param options Specifies whether this FormArray instance should emit events after a\n   *     control is removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * removed. When false, no events are emitted.\n   */\n\n\n  removeAt(index, options = {}) {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control\n   * @param control The `AbstractControl` control to replace the existing control\n   * @param options Specifies whether this FormArray instance should emit events after an\n   *     existing control is replaced with a new one.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * replaced with a new one. When false, no events are emitted.\n   */\n\n\n  setControl(index, control, options = {}) {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n\n    this._onCollectionChange();\n  }\n  /**\n   * Length of the control array.\n   */\n\n\n  get length() {\n    return this.controls.length;\n  }\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * @usageNotes\n   * ### Set the values for the controls in the form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *   new FormControl(),\n   *   new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.setValue(['Nancy', 'Drew']);\n   * console.log(arr.value);   // ['Nancy', 'Drew']\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n\n\n  setValue(value, options = {}) {\n    this._checkAllValuesPresent(value);\n\n    value.forEach((newValue, index) => {\n      this._throwIfControlMissing(index);\n\n      this.at(index).setValue(newValue, {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the values for controls in a form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.patchValue(['Nancy']);\n   * console.log(arr.value);   // ['Nancy', null]\n   * ```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control\n   * value is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n\n\n  patchValue(value, options = {}) {\n    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n    // `patchValue` can be called recursively and inner data structures might have these values,\n    // so we just ignore such cases when a field containing FormArray instance receives `null` or\n    // `undefined` as a value.\n    if (value == null\n    /* both `null` and `undefined` */\n    ) return;\n    value.forEach((newValue, index) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {\n          onlySelf: true,\n          emitEvent: options.emitEvent\n        });\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * @usageNotes\n   * ### Reset the values in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * arr.reset(['name', 'last name']);\n   *\n   * console.log(arr.value);  // ['name', 'last name']\n   * ```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n   * ```\n   * arr.reset([\n   *   {value: 'name', disabled: true},\n   *   'last'\n   * ]);\n   *\n   * console.log(arr.value);  // ['last']\n   * console.log(arr.at(0).status);  // 'DISABLED'\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n\n\n  reset(value = [], options = {}) {\n    this._forEachChild((control, index) => {\n      control.reset(value[index], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n\n    this._updatePristine(options);\n\n    this._updateTouched(options);\n\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   */\n\n\n  getRawValue() {\n    return this.controls.map((control, idx) => {\n      return control instanceof FormControl ? control.value : control.getRawValue();\n    });\n  }\n  /**\n   * Remove all controls in the `FormArray`.\n   *\n   * @param options Specifies whether this FormArray instance should emit events after all\n   *     controls are removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when all controls\n   * in this FormArray instance are removed. When false, no events are emitted.\n   *\n   * @usageNotes\n   * ### Remove all elements from a FormArray\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.length);  // 2\n   *\n   * arr.clear();\n   * console.log(arr.length);  // 0\n   * ```\n   *\n   * It's a simpler and more efficient alternative to removing all elements one by one:\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   *\n   * while (arr.length) {\n   *    arr.removeAt(0);\n   * }\n   * ```\n   */\n\n\n  clear(options = {}) {\n    if (this.controls.length < 1) return;\n\n    this._forEachChild(control => control._registerOnCollectionChange(() => {}));\n\n    this.controls.splice(0);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  /** @internal */\n\n\n  _syncPendingControls() {\n    let subtreeUpdated = this.controls.reduce((updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({\n      onlySelf: true\n    });\n    return subtreeUpdated;\n  }\n  /** @internal */\n\n\n  _throwIfControlMissing(index) {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n  /** @internal */\n\n\n  _forEachChild(cb) {\n    this.controls.forEach((c, index) => {\n      cb(c, index);\n    });\n  }\n  /** @internal */\n\n\n  _updateValue() {\n    this.value = this.controls.filter(control => control.enabled || this.disabled).map(control => control.value);\n  }\n  /** @internal */\n\n\n  _anyControls(condition) {\n    return this.controls.some(control => control.enabled && condition(control));\n  }\n  /** @internal */\n\n\n  _setUpControls() {\n    this._forEachChild(control => this._registerControl(control));\n  }\n  /** @internal */\n\n\n  _checkAllValuesPresent(value) {\n    this._forEachChild((_, i) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n  /** @internal */\n\n\n  _allControlsDisabled() {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n\n    return this.controls.length > 0 || this.disabled;\n  }\n\n  _registerControl(control) {\n    control.setParent(this);\n\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n\n}","map":{"version":3,"sources":["/home/nig/angular-typed-forms-ex-nwhadc/src/forms/src/model.ts"],"names":["EventEmitter","removeListItem","addValidators","composeAsyncValidators","composeValidators","hasValidator","removeValidators","toObservable","VALID","INVALID","PENDING","DISABLED","_find","control","path","delimiter","Array","isArray","split","length","controlToFind","forEach","name","FormGroup","controls","hasOwnProperty","FormArray","at","pickValidators","validatorOrOpts","isOptionsObj","validators","coerceToValidator","validator","pickAsyncValidators","asyncValidator","asyncValidators","coerceToAsyncValidator","AbstractControl","constructor","_pendingDirty","_hasOwnPendingAsyncValidator","_pendingTouched","_onCollectionChange","_parent","pristine","touched","_onDisabledChange","_rawValidators","_rawAsyncValidators","_composedValidatorFn","_composedAsyncValidatorFn","validatorFn","asyncValidatorFn","parent","valid","status","invalid","pending","disabled","enabled","dirty","untouched","updateOn","_updateOn","setValidators","setAsyncValidators","addAsyncValidators","removeAsyncValidators","hasAsyncValidator","clearValidators","clearAsyncValidators","markAsTouched","opts","onlySelf","markAllAsTouched","_forEachChild","markAsUntouched","_updateTouched","markAsDirty","markAsPristine","_updatePristine","markAsPending","emitEvent","statusChanges","emit","disable","skipPristineCheck","_parentMarkedDirty","errors","Object","assign","_updateValue","valueChanges","value","_updateAncestors","changeFn","enable","updateValueAndValidity","setParent","_setInitialStatus","_cancelExistingSubscription","_runValidator","_calculateStatus","_runAsyncValidator","_updateTreeValidity","ctrl","_allControlsDisabled","obs","_asyncValidationSubscription","subscribe","setErrors","unsubscribe","_updateControlsErrors","get","getError","errorCode","hasError","root","x","_initObservables","_anyControlsHaveStatus","_anyControls","_anyControlsDirty","_anyControlsTouched","_registerOnCollectionChange","fn","_setUpdateStrategy","parentDirty","isFormState","formState","keys","FormControlImpl","defaultValue","_onChange","_pendingChange","_defaultValue","undefined","_applyFormState","initialValueIsDefault","setValue","options","_pendingValue","emitModelToViewChange","emitViewToModelChange","patchValue","reset","getRawValue","condition","registerOnChange","push","_unregisterOnChange","registerOnDisabledChange","_unregisterOnDisabledChange","cb","_syncPendingControls","FormControl","_setUpControls","registerControl","addControl","removeControl","setControl","contains","controlName","_checkAllValuesPresent","_throwIfControlMissing","_reduceChildren","acc","subtreeUpdated","updated","child","Error","key","_reduceValue","initValue","res","index","_registerControl","insert","splice","removeAt","newValue","map","idx","clear","reduce","c","filter","some","_","i"],"mappings":"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4BAAL,GAAoC,KAApC;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIsE,EAAAA,SAAS,CAACtB,MAAD,EAAShB,IAAI,GAAG,EAAhB,EAAoB;AACzB,SAAKgB,MAAL,GAAcA,MAAd;;AACA,SAAKwB,qBAAL,CAA2BxC,IAAI,CAACU,SAAL,KAAmB,KAA9C;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI+B,EAAAA,GAAG,CAACpG,IAAD,EAAO;AACN,WAAOF,KAAK,CAAC,IAAD,EAAOE,IAAP,EAAa,GAAb,CAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIqG,EAAAA,QAAQ,CAACC,SAAD,EAAYtG,IAAZ,EAAkB;AACtB,UAAMD,OAAO,GAAGC,IAAI,GAAG,KAAKoG,GAAL,CAASpG,IAAT,CAAH,GAAoB,IAAxC;AACA,WAAOD,OAAO,IAAIA,OAAO,CAAC4E,MAAnB,GAA4B5E,OAAO,CAAC4E,MAAR,CAAe2B,SAAf,CAA5B,GAAwD,IAA/D;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,QAAQ,CAACD,SAAD,EAAYtG,IAAZ,EAAkB;AACtB,WAAO,CAAC,CAAC,KAAKqG,QAAL,CAAcC,SAAd,EAAyBtG,IAAzB,CAAT;AACH;AACD;AACJ;AACA;;;AACY,MAAJwG,IAAI,GAAG;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AAS,CAACpC,KAA5C;AACAoC,MAAAA,SAAS,CAACvE,QAAV,GAAqB,KAAK2B,OAAL,CAAa;AAAEZ,QAAAA,QAAQ,EAAE,IAAZ;AAAkBS,QAAAA,SAAS,EAAE;AAA7B,OAAb,CAArB,GACI,KAAKc,MAAL,CAAY;AAAEvB,QAAAA,QAAQ,EAAE,IAAZ;AAAkBS,QAAAA,SAAS,EAAE;AAA7B,OAAZ,CADJ;AAEH,KAJD,MAKK;AACD,WAAKW,KAAL,GAAa,KAAKgD,aAAL,GAAqBZ,SAAlC;AACH;AACJ;;AA3GyC,C,CA6G9C;AACA;;;AACA,OAAO,MAAM0B,WAAW,GAAGxB,eAApB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAM7G,SAAN,SAAwBe,eAAxB,CAAwC;AAC3C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACf,QAAD,EAAWK,eAAX,EAA4BM,cAA5B,EAA4C;AACnD,UAAMP,cAAc,CAACC,eAAD,CAApB,EAAuCK,mBAAmB,CAACC,cAAD,EAAiBN,eAAjB,CAA1D;AACA,SAAKL,QAAL,GAAgBA,QAAhB;;AACA,SAAKgG,gBAAL;;AACA,SAAKO,kBAAL,CAAwBlG,eAAxB;;AACA,SAAKgI,cAAL;;AACA,SAAK3D,sBAAL,CAA4B;AACxBxB,MAAAA,QAAQ,EAAE,IADc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AAmB,CAAC/D,OAAD,EAAUS,IAAV,KAAmB;AAClC,UAAIwE,KAAK,CAACxE,IAAD,CAAL,KAAgBmH,SAApB,EAA+B;AAC3B,cAAM,IAAIkC,KAAJ,CAAW,oDAAmDrJ,IAAK,IAAnE,CAAN;AACH;AACJ,KAJD;AAKH;;AAtX0C;AAwX/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMI,SAAN,SAAwBY,eAAxB,CAAwC;AAC3C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACf,QAAD,EAAWK,eAAX,EAA4BM,cAA5B,EAA4C;AACnD,UAAMP,cAAc,CAACC,eAAD,CAApB,EAAuCK,mBAAmB,CAACC,cAAD,EAAiBN,eAAjB,CAA1D;AACA,SAAKL,QAAL,GAAgBA,QAAhB;;AACA,SAAKgG,gBAAL;;AACA,SAAKO,kBAAL,CAAwBlG,eAAxB;;AACA,SAAKgI,cAAL;;AACA,SAAK3D,sBAAL,CAA4B;AACxBxB,MAAAA,QAAQ,EAAE,IADc;AAExB;AACA;AACA;AACA;AACAS,MAAAA,SAAS,EAAE,CAAC,CAAC,KAAKhD;AANM,KAA5B;AAQH;AACD;AACJ;AACA;AACA;AACA;;;AACIR,EAAAA,EAAE,CAACqJ,KAAD,EAAQ;AACN,WAAO,KAAKxJ,QAAL,CAAcwJ,KAAd,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI1B,EAAAA,IAAI,CAACzI,OAAD,EAAUgI,OAAO,GAAG,EAApB,EAAwB;A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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { EventEmitter } from '@angular/core';\nimport { removeListItem } from './directives/shared';\nimport { addValidators, composeAsyncValidators, composeValidators, hasValidator, removeValidators, toObservable } from './validators';\n/**\n * Reports that a FormControl is valid, meaning that no errors exist in the input value.\n *\n * @see `status`\n */\nexport const VALID = 'VALID';\n/**\n * Reports that a FormControl is invalid, meaning that an error exists in the input value.\n *\n * @see `status`\n */\nexport const INVALID = 'INVALID';\n/**\n * Reports that a FormControl is pending, meaning that that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see `markAsPending`\n * @see `status`\n */\nexport const PENDING = 'PENDING';\n/**\n * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see `markAsDisabled`\n * @see `status`\n */\nexport const DISABLED = 'DISABLED';\nfunction _find(control, path, delimiter) {\n    if (path == null)\n        return null;\n    if (!Array.isArray(path)) {\n        path = path.split(delimiter);\n    }\n    if (Array.isArray(path) && path.length === 0)\n        return null;\n    // Not using Array.reduce here due to a Chrome 80 bug\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n    let controlToFind = control;\n    path.forEach((name) => {\n        if (controlToFind instanceof FormGroup) {\n            controlToFind = controlToFind.controls.hasOwnProperty(name) ?\n                controlToFind.controls[name] :\n                null;\n        }\n        else if (controlToFind instanceof FormArray) {\n            controlToFind = controlToFind.at(name) || null;\n        }\n        else {\n            controlToFind = null;\n        }\n    });\n    return controlToFind;\n}\n/**\n * Gets validators from either an options object or given validators.\n */\nfunction pickValidators(validatorOrOpts) {\n    return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;\n}\n/**\n * Creates validator function by combining provided validators.\n */\nfunction coerceToValidator(validator) {\n    return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n/**\n * Gets async validators from either an options object or given validators.\n */\nfunction pickAsyncValidators(asyncValidator, validatorOrOpts) {\n    return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;\n}\n/**\n * Creates async validator function by combining provided async validators.\n */\nfunction coerceToAsyncValidator(asyncValidator) {\n    return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) :\n        asyncValidator || null;\n}\nfunction isOptionsObj(validatorOrOpts) {\n    return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&\n        typeof validatorOrOpts === 'object';\n}\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * This class has a main type parameter ValueT which represents the value type of the control.\n * That type can contain partials, due to disabled controls. The optional type parameter RawValueT\n * represents the raw value type (i.e. what the type of `rawValue` would be, or `value` with all\n * controls enabled).\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n * @publicApi\n */\nexport class AbstractControl {\n    /**\n     * Initialize the AbstractControl instance.\n     *\n     * @param validators The function or array of functions that is used to determine the validity of\n     *     this control synchronously.\n     * @param asyncValidators The function or array of functions that is used to determine validity of\n     *     this control asynchronously.\n     */\n    constructor(validators, asyncValidators) {\n        /** @internal */\n        this._pendingDirty = false;\n        /**\n         * Indicates that a control has its own pending asynchronous validation in progress.\n         *\n         * @internal\n         */\n        this._hasOwnPendingAsyncValidator = false;\n        /** @internal */\n        this._pendingTouched = false;\n        /** @internal */\n        this._onCollectionChange = () => { };\n        this._parent = null;\n        /**\n         * A control is `pristine` if the user has not yet changed\n         * the value in the UI.\n         *\n         * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n         * Programmatic changes to a control's value do not mark it dirty.\n         */\n        this.pristine = true;\n        /**\n         * True if the control is marked as `touched`.\n         *\n         * A control is marked `touched` once the user has triggered\n         * a `blur` event on it.\n         */\n        this.touched = false;\n        /** @internal */\n        this._onDisabledChange = [];\n        this._rawValidators = validators;\n        this._rawAsyncValidators = asyncValidators;\n        this._composedValidatorFn = coerceToValidator(this._rawValidators);\n        this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);\n    }\n    /**\n     * Returns the function that is used to determine the validity of this control synchronously.\n     * If multiple validators have been added, this will be a single composed function.\n     * See `Validators.compose()` for additional information.\n     */\n    get validator() {\n        return this._composedValidatorFn;\n    }\n    set validator(validatorFn) {\n        this._rawValidators = this._composedValidatorFn = validatorFn;\n    }\n    /**\n     * Returns the function that is used to determine the validity of this control asynchronously.\n     * If multiple validators have been added, this will be a single composed function.\n     * See `Validators.compose()` for additional information.\n     */\n    get asyncValidator() {\n        return this._composedAsyncValidatorFn;\n    }\n    set asyncValidator(asyncValidatorFn) {\n        this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;\n    }\n    /**\n     * The parent control.\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * A control is `valid` when its `status` is `VALID`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if the control has passed all of its validation tests,\n     * false otherwise.\n     */\n    get valid() {\n        return this.status === VALID;\n    }\n    /**\n     * A control is `invalid` when its `status` is `INVALID`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if this control has failed one or more of its validation checks,\n     * false otherwise.\n     */\n    get invalid() {\n        return this.status === INVALID;\n    }\n    /**\n     * A control is `pending` when its `status` is `PENDING`.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if this control is in the process of conducting a validation check,\n     * false otherwise.\n     */\n    get pending() {\n        return this.status == PENDING;\n    }\n    /**\n     * A control is `disabled` when its `status` is `DISABLED`.\n     *\n     * Disabled controls are exempt from validation checks and\n     * are not included in the aggregate value of their ancestor\n     * controls.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @returns True if the control is disabled, false otherwise.\n     */\n    get disabled() {\n        return this.status === DISABLED;\n    }\n    /**\n     * A control is `enabled` as long as its `status` is not `DISABLED`.\n     *\n     * @returns True if the control has any status other than 'DISABLED',\n     * false if the status is 'DISABLED'.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     */\n    get enabled() {\n        return this.status !== DISABLED;\n    }\n    /**\n     * A control is `dirty` if the user has changed the value\n     * in the UI.\n     *\n     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n     * Programmatic changes to a control's value do not mark it dirty.\n     */\n    get dirty() {\n        return !this.pristine;\n    }\n    /**\n     * True if the control has not been marked as touched\n     *\n     * A control is `untouched` if the user has not yet triggered\n     * a `blur` event on it.\n     */\n    get untouched() {\n        return !this.touched;\n    }\n    /**\n     * Reports the update strategy of the `AbstractControl` (meaning\n     * the event on which the control updates itself).\n     * Possible values: `'change'` | `'blur'` | `'submit'`\n     * Default value: `'change'`\n     */\n    get updateOn() {\n        return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');\n    }\n    /**\n     * Sets the synchronous validators that are active on this control.  Calling\n     * this overwrites any existing synchronous validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * If you want to add a new validator without affecting existing ones, consider\n     * using `addValidators()` method instead.\n     */\n    setValidators(validators) {\n        this._rawValidators = validators;\n        this._composedValidatorFn = coerceToValidator(validators);\n    }\n    /**\n     * Sets the asynchronous validators that are active on this control. Calling this\n     * overwrites any existing asynchronous validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * If you want to add a new validator without affecting existing ones, consider\n     * using `addAsyncValidators()` method instead.\n     */\n    setAsyncValidators(validators) {\n        this._rawAsyncValidators = validators;\n        this._composedAsyncValidatorFn = coerceToAsyncValidator(validators);\n    }\n    /**\n     * Add a synchronous validator or validators to this control, without affecting other validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * Adding a validator that already exists will have no effect. If duplicate validator functions\n     * are present in the `validators` array, only the first instance would be added to a form\n     * control.\n     *\n     * @param validators The new validator function or functions to add to this control.\n     */\n    addValidators(validators) {\n        this.setValidators(addValidators(validators, this._rawValidators));\n    }\n    /**\n     * Add an asynchronous validator or validators to this control, without affecting other\n     * validators.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * Adding a validator that already exists will have no effect.\n     *\n     * @param validators The new asynchronous validator function or functions to add to this control.\n     */\n    addAsyncValidators(validators) {\n        this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));\n    }\n    /**\n     * Remove a synchronous validator from this control, without affecting other validators.\n     * Validators are compared by function reference; you must pass a reference to the exact same\n     * validator function as the one that was originally set. If a provided validator is not found,\n     * it is ignored.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * @param validators The validator or validators to remove.\n     */\n    removeValidators(validators) {\n        this.setValidators(removeValidators(validators, this._rawValidators));\n    }\n    /**\n     * Remove an asynchronous validator from this control, without affecting other validators.\n     * Validators are compared by function reference; you must pass a reference to the exact same\n     * validator function as the one that was originally set. If a provided validator is not found, it\n     * is ignored.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     * @param validators The asynchronous validator or validators to remove.\n     */\n    removeAsyncValidators(validators) {\n        this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));\n    }\n    /**\n     * Check whether a synchronous validator function is present on this control. The provided\n     * validator must be a reference to the exact same function that was provided.\n     *\n     * @param validator The validator to check for presence. Compared by function reference.\n     * @returns Whether the provided validator was found on this control.\n     */\n    hasValidator(validator) {\n        return hasValidator(this._rawValidators, validator);\n    }\n    /**\n     * Check whether an asynchronous validator function is present on this control. The provided\n     * validator must be a reference to the exact same function that was provided.\n     *\n     * @param validator The asynchronous validator to check for presence. Compared by function\n     *     reference.\n     * @returns Whether the provided asynchronous validator was found on this control.\n     */\n    hasAsyncValidator(validator) {\n        return hasValidator(this._rawAsyncValidators, validator);\n    }\n    /**\n     * Empties out the synchronous validator list.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     */\n    clearValidators() {\n        this.validator = null;\n    }\n    /**\n     * Empties out the async validator list.\n     *\n     * When you add or remove a validator at run time, you must call\n     * `updateValueAndValidity()` for the new validation to take effect.\n     *\n     */\n    clearAsyncValidators() {\n        this.asyncValidator = null;\n    }\n    /**\n     * Marks the control as `touched`. A control is touched by focus and\n     * blur events that do not change the value.\n     *\n     * @see `markAsUntouched()`\n     * @see `markAsDirty()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsTouched(opts = {}) {\n        this.touched = true;\n        if (this._parent && !opts.onlySelf) {\n            this._parent.markAsTouched(opts);\n        }\n    }\n    /**\n     * Marks the control and all its descendant controls as `touched`.\n     * @see `markAsTouched()`\n     */\n    markAllAsTouched() {\n        this.markAsTouched({ onlySelf: true });\n        this._forEachChild((control) => control.markAllAsTouched());\n    }\n    /**\n     * Marks the control as `untouched`.\n     *\n     * If the control has any children, also marks all children as `untouched`\n     * and recalculates the `touched` status of all parent controls.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsDirty()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after the marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsUntouched(opts = {}) {\n        this.touched = false;\n        this._pendingTouched = false;\n        this._forEachChild((control) => {\n            control.markAsUntouched({ onlySelf: true });\n        });\n        if (this._parent && !opts.onlySelf) {\n            this._parent._updateTouched(opts);\n        }\n    }\n    /**\n     * Marks the control as `dirty`. A control becomes dirty when\n     * the control's value is changed through the UI; compare `markAsTouched`.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsUntouched()`\n     * @see `markAsPristine()`\n     *\n     * @param opts Configuration options that determine how the control propagates changes\n     * and emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsDirty(opts = {}) {\n        this.pristine = false;\n        if (this._parent && !opts.onlySelf) {\n            this._parent.markAsDirty(opts);\n        }\n    }\n    /**\n     * Marks the control as `pristine`.\n     *\n     * If the control has any children, marks all children as `pristine`,\n     * and recalculates the `pristine` status of all parent\n     * controls.\n     *\n     * @see `markAsTouched()`\n     * @see `markAsUntouched()`\n     * @see `markAsDirty()`\n     *\n     * @param opts Configuration options that determine how the control emits events after\n     * marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     */\n    markAsPristine(opts = {}) {\n        this.pristine = true;\n        this._pendingDirty = false;\n        this._forEachChild((control) => {\n            control.markAsPristine({ onlySelf: true });\n        });\n        if (this._parent && !opts.onlySelf) {\n            this._parent._updatePristine(opts);\n        }\n    }\n    /**\n     * Marks the control as `pending`.\n     *\n     * A control is pending while the control performs async validation.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configuration options that determine how the control propagates changes and\n     * emits events after marking is applied.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n     * observable emits an event with the latest status the control is marked pending.\n     * When false, no events are emitted.\n     *\n     */\n    markAsPending(opts = {}) {\n        this.status = PENDING;\n        if (opts.emitEvent !== false) {\n            this.statusChanges.emit(this.status);\n        }\n        if (this._parent && !opts.onlySelf) {\n            this._parent.markAsPending(opts);\n        }\n    }\n    /**\n     * Disables the control. This means the control is exempt from validation checks and\n     * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n     *\n     * If the control has children, all children are also disabled.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configuration options that determine how the control propagates\n     * changes and emits events after the control is disabled.\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is disabled.\n     * When false, no events are emitted.\n     */\n    disable(opts = {}) {\n        // If parent has been marked artificially dirty we don't want to re-calculate the\n        // parent's dirtiness based on the children.\n        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n        this.status = DISABLED;\n        this.errors = null;\n        this._forEachChild((control) => {\n            control.disable(Object.assign(Object.assign({}, opts), { onlySelf: true }));\n        });\n        this._updateValue();\n        if (opts.emitEvent !== false) {\n            this.valueChanges.emit(this.value);\n            this.statusChanges.emit(this.status);\n        }\n        this._updateAncestors(Object.assign(Object.assign({}, opts), { skipPristineCheck }));\n        this._onDisabledChange.forEach((changeFn) => changeFn(true));\n    }\n    /**\n     * Enables the control. This means the control is included in validation checks and\n     * the aggregate value of its parent. Its status recalculates based on its value and\n     * its validators.\n     *\n     * By default, if the control has children, all children are enabled.\n     *\n     * @see {@link AbstractControl.status}\n     *\n     * @param opts Configure options that control how the control propagates changes and\n     * emits events when marked as untouched\n     * * `onlySelf`: When true, mark only this control. When false or not supplied,\n     * marks all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is enabled.\n     * When false, no events are emitted.\n     */\n    enable(opts = {}) {\n        // If parent has been marked artificially dirty we don't want to re-calculate the\n        // parent's dirtiness based on the children.\n        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n        this.status = VALID;\n        this._forEachChild((control) => {\n            control.enable(Object.assign(Object.assign({}, opts), { onlySelf: true }));\n        });\n        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });\n        this._updateAncestors(Object.assign(Object.assign({}, opts), { skipPristineCheck }));\n        this._onDisabledChange.forEach((changeFn) => changeFn(false));\n    }\n    _updateAncestors(opts) {\n        if (this._parent && !opts.onlySelf) {\n            this._parent.updateValueAndValidity(opts);\n            if (!opts.skipPristineCheck) {\n                this._parent._updatePristine();\n            }\n            this._parent._updateTouched();\n        }\n    }\n    /**\n     * Sets the parent of the control\n     *\n     * @param parent The new parent.\n     */\n    setParent(parent) {\n        this._parent = parent;\n    }\n    /**\n     * Recalculates the value and validation status of the control.\n     *\n     * By default, it also updates the value and validity of its ancestors.\n     *\n     * @param opts Configuration options determine how the control propagates changes and emits events\n     * after updates and validity checks are applied.\n     * * `onlySelf`: When true, only update this control. When false or not supplied,\n     * update all direct ancestors. Default is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is updated.\n     * When false, no events are emitted.\n     */\n    updateValueAndValidity(opts = {}) {\n        this._setInitialStatus();\n        this._updateValue();\n        if (this.enabled) {\n            this._cancelExistingSubscription();\n            this.errors = this._runValidator();\n            this.status = this._calculateStatus();\n            if (this.status === VALID || this.status === PENDING) {\n                this._runAsyncValidator(opts.emitEvent);\n            }\n        }\n        if (opts.emitEvent !== false) {\n            this.valueChanges.emit(this.value);\n            this.statusChanges.emit(this.status);\n        }\n        if (this._parent && !opts.onlySelf) {\n            this._parent.updateValueAndValidity(opts);\n        }\n    }\n    /** @internal */\n    _updateTreeValidity(opts = { emitEvent: true }) {\n        this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));\n        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });\n    }\n    _setInitialStatus() {\n        this.status = this._allControlsDisabled() ? DISABLED : VALID;\n    }\n    _runValidator() {\n        return this.validator ? this.validator(this) : null;\n    }\n    _runAsyncValidator(emitEvent) {\n        if (this.asyncValidator) {\n            this.status = PENDING;\n            this._hasOwnPendingAsyncValidator = true;\n            const obs = toObservable(this.asyncValidator(this));\n            this._asyncValidationSubscription = obs.subscribe((errors) => {\n                this._hasOwnPendingAsyncValidator = false;\n                // This will trigger the recalculation of the validation status, which depends on\n                // the state of the asynchronous validation (whether it is in progress or not). So, it is\n                // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.\n                this.setErrors(errors, { emitEvent });\n            });\n        }\n    }\n    _cancelExistingSubscription() {\n        if (this._asyncValidationSubscription) {\n            this._asyncValidationSubscription.unsubscribe();\n            this._hasOwnPendingAsyncValidator = false;\n        }\n    }\n    /**\n     * Sets errors on a form control when running validations manually, rather than automatically.\n     *\n     * Calling `setErrors` also updates the validity of the parent control.\n     *\n     * @usageNotes\n     *\n     * ### Manually set the errors for a control\n     *\n     * ```\n     * const login = new FormControl('someLogin');\n     * login.setErrors({\n     *   notUnique: true\n     * });\n     *\n     * expect(login.valid).toEqual(false);\n     * expect(login.errors).toEqual({ notUnique: true });\n     *\n     * login.setValue('someOtherLogin');\n     *\n     * expect(login.valid).toEqual(true);\n     * ```\n     */\n    setErrors(errors, opts = {}) {\n        this.errors = errors;\n        this._updateControlsErrors(opts.emitEvent !== false);\n    }\n    /**\n     * Retrieves a child control given the control's name or path.\n     *\n     * @param path A dot-delimited string or array of string/number values that define the path to the\n     * control. If a string is provided, passing it as a string literal will result in improved type\n     * information. Likewise, if an array is provided, passing it `as const` will cause improved type\n     * information to be available.\n     *\n     * @usageNotes\n     * ### Retrieve a nested control\n     *\n     * For example, to get a `name` control nested within a `person` sub-group:\n     *\n     * * `this.form.get('person.name');`\n     *\n     * -OR-\n     *\n     * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings\n     *\n     * ### Retrieve a control in a FormArray\n     *\n     * When accessing an element inside a FormArray, you can use an element index.\n     * For example, to get a `price` control from the first element in an `items` array you can use:\n     *\n     * * `this.form.get('items.0.price');`\n     *\n     * -OR-\n     *\n     * * `this.form.get(['items', 0, 'price']);`\n     */\n    get(path) {\n        return _find(this, path, '.');\n    }\n    /**\n     * @description\n     * Reports error data for the control with the given path.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode, path) {\n        const control = path ? this.get(path) : this;\n        return control && control.errors ? control.errors[errorCode] : null;\n    }\n    /**\n     * @description\n     * Reports whether the control with the given path has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * If no path is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given path.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode, path) {\n        return !!this.getError(errorCode, path);\n    }\n    /**\n     * Retrieves the top-level ancestor of this control.\n     */\n    get root() {\n        let x = this;\n        while (x._parent) {\n            x = x._parent;\n        }\n        return x;\n    }\n    /** @internal */\n    _updateControlsErrors(emitEvent) {\n        this.status = this._calculateStatus();\n        if (emitEvent) {\n            this.statusChanges.emit(this.status);\n        }\n        if (this._parent) {\n            this._parent._updateControlsErrors(emitEvent);\n        }\n    }\n    /** @internal */\n    _initObservables() {\n        this.valueChanges = new EventEmitter();\n        this.statusChanges = new EventEmitter();\n    }\n    _calculateStatus() {\n        if (this._allControlsDisabled())\n            return DISABLED;\n        if (this.errors)\n            return INVALID;\n        if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING))\n            return PENDING;\n        if (this._anyControlsHaveStatus(INVALID))\n            return INVALID;\n        return VALID;\n    }\n    /** @internal */\n    _anyControlsHaveStatus(status) {\n        return this._anyControls((control) => control.status === status);\n    }\n    /** @internal */\n    _anyControlsDirty() {\n        return this._anyControls((control) => control.dirty);\n    }\n    /** @internal */\n    _anyControlsTouched() {\n        return this._anyControls((control) => control.touched);\n    }\n    /** @internal */\n    _updatePristine(opts = {}) {\n        this.pristine = !this._anyControlsDirty();\n        if (this._parent && !opts.onlySelf) {\n            this._parent._updatePristine(opts);\n        }\n    }\n    /** @internal */\n    _updateTouched(opts = {}) {\n        this.touched = this._anyControlsTouched();\n        if (this._parent && !opts.onlySelf) {\n            this._parent._updateTouched(opts);\n        }\n    }\n    /** @internal */\n    _registerOnCollectionChange(fn) {\n        this._onCollectionChange = fn;\n    }\n    /** @internal */\n    _setUpdateStrategy(opts) {\n        if (isOptionsObj(opts) && opts.updateOn != null) {\n            this._updateOn = opts.updateOn;\n        }\n    }\n    /**\n     * Check to see if parent has been marked artificially dirty.\n     *\n     * @internal\n     */\n    _parentMarkedDirty(onlySelf) {\n        const parentDirty = this._parent && this._parent.dirty;\n        return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();\n    }\n}\nfunction isFormState(formState) {\n    return typeof formState === 'object' && formState !== null &&\n        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n}\nclass FormControlImpl extends AbstractControl {\n    constructor(\n    // formState and defaultValue will only be null if T is nullable\n    formState = null, validatorOrOpts, asyncValidator, defaultValue) {\n        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n        this.defaultValue = null;\n        /** @internal */\n        this._onChange = [];\n        /** @internal */\n        this._pendingChange = false;\n        /** @internal */\n        this._defaultValue = null;\n        this._defaultValue =\n            (defaultValue === undefined ? null : defaultValue);\n        this._applyFormState(formState);\n        this._setUpdateStrategy(validatorOrOpts);\n        this._initObservables();\n        this.updateValueAndValidity({\n            onlySelf: true,\n            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n            // `VALID` or `INVALID`.\n            // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n            // to `true` to allow that during the control creation process.\n            emitEvent: !!this.asyncValidator\n        });\n        if (isOptionsObj(validatorOrOpts) && validatorOrOpts.initialValueIsDefault) {\n            if (isFormState(formState)) {\n                this.defaultValue = formState.value;\n            }\n            else {\n                this.defaultValue = formState;\n            }\n        }\n    }\n    setValue(value, options = {}) {\n        this.value = this._pendingValue = value;\n        if (this._onChange.length && options.emitModelToViewChange !== false) {\n            this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));\n        }\n        this.updateValueAndValidity(options);\n    }\n    patchValue(value, options = {}) {\n        this.setValue(value, options);\n    }\n    reset(formState = this._defaultValue, options = {}) {\n        this._applyFormState(formState);\n        this.markAsPristine(options);\n        this.markAsUntouched(options);\n        this.setValue(this.value, options);\n        this._pendingChange = false;\n    }\n    getRawValue() {\n        return this.value;\n    }\n    /** @internal */\n    _updateValue() { }\n    /** @internal */\n    _anyControls(condition) {\n        return false;\n    }\n    /** @internal */\n    _allControlsDisabled() {\n        return this.disabled;\n    }\n    registerOnChange(fn) {\n        this._onChange.push(fn);\n    }\n    /**\n     * Internal function to unregister a change events listener.\n     * @internal\n     */\n    _unregisterOnChange(fn) {\n        removeListItem(this._onChange, fn);\n    }\n    registerOnDisabledChange(fn) {\n        this._onDisabledChange.push(fn);\n    }\n    /** @internal */\n    _unregisterOnDisabledChange(fn) {\n        removeListItem(this._onDisabledChange, fn);\n    }\n    /** @internal */\n    _forEachChild(cb) { }\n    /** @internal */\n    _syncPendingControls() {\n        if (this.updateOn === 'submit') {\n            if (this._pendingDirty)\n                this.markAsDirty();\n            if (this._pendingTouched)\n                this.markAsTouched();\n            if (this._pendingChange) {\n                this.setValue(this._pendingValue, { onlySelf: true, emitModelToViewChange: false });\n                return true;\n            }\n        }\n        return false;\n    }\n    /** @internal */\n    _applyFormState(formState) {\n        if (isFormState(formState)) {\n            this.value = this._pendingValue = formState.value;\n            formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :\n                this.enable({ onlySelf: true, emitEvent: false });\n        }\n        else {\n            this.value = this._pendingValue = formState;\n        }\n    }\n}\n// The constructor for FormControl is decoupled from its implementation.\n// This allows us to provide multiple constructor signatures.\nexport const FormControl = FormControlImpl;\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormArray`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * `FormGroup` accepts an optional type parameter `CtrlT`, which is an object type with inner\n * control types as values.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n *\n * ### Using a FormGroup with optional controls\n *\n * It is possible to have optional controls in a FormGroup. An optional control can be removed later\n * using `removeControl`, and can be omitted when calling `reset`. Optional controls must be\n * declared optional in the group's type.\n *\n * ```ts\n * const c = new FormGroup<{one?: FormControl<string>}>({\n *   one: new FormControl('')\n * });\n * ```\n *\n * Notice that `c.value.one` has type `string|null|undefined`. This is because calling `c.reset({})`\n * without providing the optional key `one` will cause it to become `null`.\n *\n * @publicApi\n */\nexport class FormGroup extends AbstractControl {\n    /**\n     * Creates a new `FormGroup` instance.\n     *\n     * @param controls A collection of child controls. The key for each child is the name\n     * under which it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(controls, validatorOrOpts, asyncValidator) {\n        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n        this.controls = controls;\n        this._initObservables();\n        this._setUpdateStrategy(validatorOrOpts);\n        this._setUpControls();\n        this.updateValueAndValidity({\n            onlySelf: true,\n            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n            // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,\n            // so we set `emitEvent` to `true` to allow that during the control creation process.\n            emitEvent: !!this.asyncValidator\n        });\n    }\n    /**\n     * Registers a control with the group's list of controls. In a strongly-typed group, the control\n     * must be in the group's type (possibly as an optional key).\n     *\n     * This method does not update the value or validity of the control.\n     * Use {@link FormGroup#addControl addControl} instead.\n     *\n     * @param name The control name to register in the collection\n     * @param control Provides the control for the given name\n     */\n    registerControl(name, control) {\n        if (this.controls[name])\n            return this.controls[name];\n        this.controls[name] = control;\n        control.setParent(this);\n        control._registerOnCollectionChange(this._onCollectionChange);\n        return control;\n    }\n    /**\n     * Add a control to this group. In a strongly-typed group, the control must be in the group's type\n     * (possibly as an optional key).\n     *\n     * If a control with a given name already exists, it would *not* be replaced with a new one.\n     * If you want to replace an existing control, use the {@link FormGroup#setControl setControl}\n     * method instead. This method also updates the value and validity of the control.\n     *\n     * @param name The control name to add to the collection\n     * @param control Provides the control for the given name\n     * @param options Specifies whether this FormGroup instance should emit events after a new\n     *     control is added.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * added. When false, no events are emitted.\n     */\n    addControl(name, control, options = {}) {\n        this.registerControl(name, control);\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n        this._onCollectionChange();\n    }\n    /**\n     * Remove a control from this group. In a strongly-typed group, required controls cannot be\n     * removed.\n     *\n     * This method also updates the value and validity of the control.\n     *\n     * @param name The control name to remove from the collection\n     * @param options Specifies whether this FormGroup instance should emit events after a\n     *     control is removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * removed. When false, no events are emitted.\n     */\n    removeControl(name, options = {}) {\n        if (this.controls[name])\n            this.controls[name]._registerOnCollectionChange(() => { });\n        delete (this.controls[name]);\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n        this._onCollectionChange();\n    }\n    /**\n     * Replace an existing control. In a strongly-typed group, the control must be in the group's type\n     * (possibly as an optional key).\n     *\n     * If a control with a given name does not exist in this `FormGroup`, it will be added.\n     *\n     * @param name The control name to replace in the collection\n     * @param control Provides the control for the given name\n     * @param options Specifies whether this FormGroup instance should emit events after an\n     *     existing control is replaced.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * replaced with a new one. When false, no events are emitted.\n     */\n    setControl(name, control, options = {}) {\n        if (this.controls[name])\n            this.controls[name]._registerOnCollectionChange(() => { });\n        delete (this.controls[name]);\n        if (control)\n            this.registerControl(name, control);\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n        this._onCollectionChange();\n    }\n    /**\n     * Check whether there is an enabled control with the given name in the group.\n     *\n     * Reports false for disabled controls. If you'd like to check for existence in the group\n     * only, use {@link AbstractControl#get get} instead.\n     *\n     * @param controlName The control name to check for existence in the collection\n     *\n     * @returns false for disabled controls, true otherwise.\n     */\n    contains(controlName) {\n        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n    }\n    /**\n     * Sets the value of the `FormGroup`. It accepts an object that matches\n     * the structure of the group, with control names as keys.\n     *\n     * @usageNotes\n     * ### Set the complete value for the form group\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl(),\n     *   last: new FormControl()\n     * });\n     *\n     * console.log(form.value);   // {first: null, last: null}\n     *\n     * form.setValue({first: 'Nancy', last: 'Drew'});\n     * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n     * ```\n     *\n     * @throws When strict checks fail, such as setting the value of a control\n     * that doesn't exist or if you exclude a value of a control that does exist.\n     *\n     * @param value The new value for the control that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events after the value changes.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     */\n    setValue(value, options = {}) {\n        this._checkAllValuesPresent(value);\n        Object.keys(value).forEach(name => {\n            this._throwIfControlMissing(name);\n            this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: options.emitEvent });\n        });\n        this.updateValueAndValidity(options);\n    }\n    /**\n     * Patches the value of the `FormGroup`. It accepts an object with control\n     * names as keys, and does its best to match the values to the correct controls\n     * in the group.\n     *\n     * It accepts both super-sets and sub-sets of the group without throwing an error.\n     *\n     * @usageNotes\n     * ### Patch the value for a form group\n     *\n     * ```\n     * const form = new FormGroup({\n     *    first: new FormControl(),\n     *    last: new FormControl()\n     * });\n     * console.log(form.value);   // {first: null, last: null}\n     *\n     * form.patchValue({first: 'Nancy'});\n     * console.log(form.value);   // {first: 'Nancy', last: null}\n     * ```\n     *\n     * @param value The object that matches the structure of the group.\n     * @param options Configuration options that determine how the control propagates changes and\n     * emits events after the value is patched.\n     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n     * true.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control value\n     * is updated. When false, no events are emitted. The configuration options are passed to\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n     */\n    patchValue(value, options = {}) {\n        // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n        // `patchValue` can be called recursively and inner data structures might have these values, so\n        // we just ignore such cases when a field containing FormGroup instance receives `null` or\n        // `undefined` as a value.\n        if (value == null /* both `null` and `undefined` */)\n            return;\n        Object.keys(value).forEach(name => {\n            if (this.controls[name]) {\n                this.controls[name].patchValue(\n                /* Guaranteed to be present, due to the outer forEach. */ value[name], { onlySelf: true, emitEvent: options.emitEvent });\n            }\n        });\n        this.updateValueAndValidity(options);\n    }\n    /**\n     * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n     * the value of all descendants to their default values, or null if no defaults were provided.\n     *\n     * You reset to a specific form state by passing in a map of states\n     * that matches the structure of your form, with control names as keys. The state\n     * is a standalone value or a form state object with both a value and a disabled\n     * status.\n     *\n     * @param value Resets the control with an initial value,\n     * or an object that defines the initial value and disabled state.\n     *\n     * @param options Configuration options that determine how the control propagates changes\n     * and emits events when the group is reset.\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n     * false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     *\n     * @usageNotes\n     *\n     * ### Reset the form group values\n     *\n     * ```ts\n     * const form = new FormGroup({\n     *   first: new FormControl('first name'),\n     *   last: new FormControl('last name')\n     * });\n     *\n     * console.log(form.value);  // {first: 'first name', last: 'last name'}\n     *\n     * form.reset({ first: 'name', last: 'last name' });\n     *\n     * console.log(form.value);  // {first: 'name', last: 'last name'}\n     * ```\n     *\n     * ### Reset the form group values and disabled status\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl('first name'),\n     *   last: new FormControl('last name')\n     * });\n     *\n     * form.reset({\n     *   first: {value: 'name', disabled: true},\n     *   last: 'last'\n     * });\n     *\n     * console.log(form.value);  // {last: 'last'}\n     * console.log(form.get('first').status);  // 'DISABLED'\n     * ```\n     */\n    reset(value = {}, options = {}) {\n        this._forEachChild((control, name) => {\n            control.reset(value[name], { onlySelf: true, emitEvent: options.emitEvent });\n        });\n        this._updatePristine(options);\n        this._updateTouched(options);\n        this.updateValueAndValidity(options);\n    }\n    /**\n     * The aggregate value of the `FormGroup`, including any disabled controls.\n     *\n     * Retrieves all values regardless of disabled status.\n     */\n    getRawValue() {\n        return this._reduceChildren({}, (acc, control, name) => {\n            acc[name] = control.getRawValue();\n            return acc;\n        });\n    }\n    /** @internal */\n    _syncPendingControls() {\n        let subtreeUpdated = this._reduceChildren(false, (updated, child) => {\n            return child._syncPendingControls() ? true : updated;\n        });\n        if (subtreeUpdated)\n            this.updateValueAndValidity({ onlySelf: true });\n        return subtreeUpdated;\n    }\n    /** @internal */\n    _throwIfControlMissing(name) {\n        if (!Object.keys(this.controls).length) {\n            throw new Error(`\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n        }\n        if (!this.controls[name]) {\n            throw new Error(`Cannot find form control with name: ${name}.`);\n        }\n    }\n    /** @internal */\n    _forEachChild(cb) {\n        Object.keys(this.controls).forEach(key => {\n            // The list of controls can change (for ex. controls might be removed) while the loop\n            // is running (as a result of invoking Forms API in `valueChanges` subscription), so we\n            // have to null check before invoking the callback.\n            const control = this.controls[key];\n            control && cb(control, key);\n        });\n    }\n    /** @internal */\n    _setUpControls() {\n        this._forEachChild((control) => {\n            control.setParent(this);\n            control._registerOnCollectionChange(this._onCollectionChange);\n        });\n    }\n    /** @internal */\n    _updateValue() {\n        this.value = this._reduceValue();\n    }\n    /** @internal */\n    _anyControls(condition) {\n        for (const controlName of Object.keys(this.controls)) {\n            const control = this.controls[controlName];\n            if (this.contains(controlName) && condition(control)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /** @internal */\n    _reduceValue() {\n        let acc = {};\n        return this._reduceChildren(acc, (acc, control, name) => {\n            if (control.enabled || this.disabled) {\n                acc[name] = control.value;\n            }\n            return acc;\n        });\n    }\n    /** @internal */\n    _reduceChildren(initValue, fn) {\n        let res = initValue;\n        this._forEachChild((control, name) => {\n            res = fn(res, control, name);\n        });\n        return res;\n    }\n    /** @internal */\n    _allControlsDisabled() {\n        for (const controlName of Object.keys(this.controls)) {\n            if (this.controls[controlName].enabled) {\n                return false;\n            }\n        }\n        return Object.keys(this.controls).length > 0 || this.disabled;\n    }\n    /** @internal */\n    _checkAllValuesPresent(value) {\n        this._forEachChild((control, name) => {\n            if (value[name] === undefined) {\n                throw new Error(`Must supply a value for form control with name: '${name}'.`);\n            }\n        });\n    }\n}\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormGroup`.\n *\n * `FormArray` accepts an optional type parameter `CtrlT`, which should be an array containing the\n * types of inner controls. If an untyped `FormArray` is desired, `any[]` should be explicitly\n * specified.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n * @publicApi\n */\nexport class FormArray extends AbstractControl {\n    /**\n     * Creates a new `FormArray` instance.\n     *\n     * @param controls An array of child controls. Each child control is given an index\n     * where it is registered.\n     *\n     * @param validatorOrOpts A synchronous validator function, or an array of\n     * such functions, or an `AbstractControlOptions` object that contains validation functions\n     * and a validation trigger.\n     *\n     * @param asyncValidator A single async validator or array of async validator functions\n     *\n     */\n    constructor(controls, validatorOrOpts, asyncValidator) {\n        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n        this.controls = controls;\n        this._initObservables();\n        this._setUpdateStrategy(validatorOrOpts);\n        this._setUpControls();\n        this.updateValueAndValidity({\n            onlySelf: true,\n            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n            // `VALID` or `INVALID`.\n            // The status should be broadcasted via the `statusChanges` observable, so we set\n            // `emitEvent` to `true` to allow that during the control creation process.\n            emitEvent: !!this.asyncValidator\n        });\n    }\n    /**\n     * Get the `AbstractControl` at the given `index` in the array.\n     *\n     * @param index Index in the array to retrieve the control\n     */\n    at(index) {\n        return this.controls[index];\n    }\n    /**\n     * Insert a new `AbstractControl` at the end of the array.\n     *\n     * @param control Form control to be inserted\n     * @param options Specifies whether this FormArray instance should emit events after a new\n     *     control is added.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * inserted. When false, no events are emitted.\n     */\n    push(control, options = {}) {\n        this.controls.push(control);\n        this._registerControl(control);\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n        this._onCollectionChange();\n    }\n    /**\n     * Insert a new `AbstractControl` at the given `index` in the array.\n     *\n     * @param index Index in the array to insert the control\n     * @param control Form control to be inserted\n     * @param options Specifies whether this FormArray instance should emit events after a new\n     *     control is inserted.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * inserted. When false, no events are emitted.\n     */\n    insert(index, control, options = {}) {\n        this.controls.splice(index, 0, control);\n        this._registerControl(control);\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n    }\n    /**\n     * Remove the control at the given `index` in the array.\n     *\n     * @param index Index in the array to remove the control\n     * @param options Specifies whether this FormArray instance should emit events after a\n     *     control is removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * removed. When false, no events are emitted.\n     */\n    removeAt(index, options = {}) {\n        if (this.controls[index])\n            this.controls[index]._registerOnCollectionChange(() => { });\n        this.controls.splice(index, 1);\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n    }\n    /**\n     * Replace an existing control.\n     *\n     * @param index Index in the array to replace the control\n     * @param control The `AbstractControl` control to replace the existing control\n     * @param options Specifies whether this FormArray instance should emit events after an\n     *     existing control is replaced with a new one.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control is\n     * replaced with a new one. When false, no events are emitted.\n     */\n    setControl(index, control, options = {}) {\n        if (this.controls[index])\n            this.controls[index]._registerOnCollectionChange(() => { });\n        this.controls.splice(index, 1);\n        if (control) {\n            this.controls.splice(index, 0, control);\n            this._registerControl(control);\n        }\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n        this._onCollectionChange();\n    }\n    /**\n     * Length of the control array.\n     */\n    get length() {\n        return this.controls.length;\n    }\n    /**\n     * Sets the value of the `FormArray`. It accepts an array that matches\n     * the structure of the control.\n     *\n     * This method performs strict checks, and throws an error if you try\n     * to set the value of a control that doesn't exist or if you exclude the\n     * value of a control.\n     *\n     * @usageNotes\n     * ### Set the values for the controls in the form array\n     *\n     * ```\n     * const arr = new FormArray([\n     *   new FormControl(),\n     *   new FormControl()\n     * ]);\n     * console.log(arr.value);   // [null, null]\n     *\n     * arr.setValue(['Nancy', 'Drew']);\n     * console.log(arr.value);   // ['Nancy', 'Drew']\n     * ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control value is updated.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     */\n    setValue(value, options = {}) {\n        this._checkAllValuesPresent(value);\n        value.forEach((newValue, index) => {\n            this._throwIfControlMissing(index);\n            this.at(index).setValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });\n        });\n        this.updateValueAndValidity(options);\n    }\n    /**\n     * Patches the value of the `FormArray`. It accepts an array that matches the\n     * structure of the control, and does its best to match the values to the correct\n     * controls in the group.\n     *\n     * It accepts both super-sets and sub-sets of the array without throwing an error.\n     *\n     * @usageNotes\n     * ### Patch the values for controls in a form array\n     *\n     * ```\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * console.log(arr.value);   // [null, null]\n     *\n     * arr.patchValue(['Nancy']);\n     * console.log(arr.value);   // ['Nancy', null]\n     * ```\n     *\n     * @param value Array of latest values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when the control\n     * value is updated. When false, no events are emitted. The configuration options are passed to\n     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n     */\n    patchValue(value, options = {}) {\n        // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n        // `patchValue` can be called recursively and inner data structures might have these values,\n        // so we just ignore such cases when a field containing FormArray instance receives `null` or\n        // `undefined` as a value.\n        if (value == null /* both `null` and `undefined` */)\n            return;\n        value.forEach((newValue, index) => {\n            if (this.at(index)) {\n                this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });\n            }\n        });\n        this.updateValueAndValidity(options);\n    }\n    /**\n     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n     * value of all descendants to null or null maps.\n     *\n     * You reset to a specific form state by passing in an array of states\n     * that matches the structure of the control. The state is a standalone value\n     * or a form state object with both a value and a disabled status.\n     *\n     * @usageNotes\n     * ### Reset the values in a form array\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * arr.reset(['name', 'last name']);\n     *\n     * console.log(arr.value);  // ['name', 'last name']\n     * ```\n     *\n     * ### Reset the values in a form array and the disabled status for the first control\n     *\n     * ```\n     * arr.reset([\n     *   {value: 'name', disabled: true},\n     *   'last'\n     * ]);\n     *\n     * console.log(arr.value);  // ['last']\n     * console.log(arr.at(0).status);  // 'DISABLED'\n     * ```\n     *\n     * @param value Array of values for the controls\n     * @param options Configure options that determine how the control propagates changes and\n     * emits events after the value changes\n     *\n     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n     * is false.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges`\n     * observables emit events with the latest status and value when the control is reset.\n     * When false, no events are emitted.\n     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n     * updateValueAndValidity} method.\n     */\n    reset(value = [], options = {}) {\n        this._forEachChild((control, index) => {\n            control.reset(value[index], { onlySelf: true, emitEvent: options.emitEvent });\n        });\n        this._updatePristine(options);\n        this._updateTouched(options);\n        this.updateValueAndValidity(options);\n    }\n    /**\n     * The aggregate value of the array, including any disabled controls.\n     *\n     * Reports all values regardless of disabled status.\n     */\n    getRawValue() {\n        return this.controls.map((control, idx) => {\n            return control instanceof FormControl ? control.value : control.getRawValue();\n        });\n    }\n    /**\n     * Remove all controls in the `FormArray`.\n     *\n     * @param options Specifies whether this FormArray instance should emit events after all\n     *     controls are removed.\n     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n     * `valueChanges` observables emit events with the latest status and value when all controls\n     * in this FormArray instance are removed. When false, no events are emitted.\n     *\n     * @usageNotes\n     * ### Remove all elements from a FormArray\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     * console.log(arr.length);  // 2\n     *\n     * arr.clear();\n     * console.log(arr.length);  // 0\n     * ```\n     *\n     * It's a simpler and more efficient alternative to removing all elements one by one:\n     *\n     * ```ts\n     * const arr = new FormArray([\n     *    new FormControl(),\n     *    new FormControl()\n     * ]);\n     *\n     * while (arr.length) {\n     *    arr.removeAt(0);\n     * }\n     * ```\n     */\n    clear(options = {}) {\n        if (this.controls.length < 1)\n            return;\n        this._forEachChild((control) => control._registerOnCollectionChange(() => { }));\n        this.controls.splice(0);\n        this.updateValueAndValidity({ emitEvent: options.emitEvent });\n    }\n    /** @internal */\n    _syncPendingControls() {\n        let subtreeUpdated = this.controls.reduce((updated, child) => {\n            return child._syncPendingControls() ? true : updated;\n        }, false);\n        if (subtreeUpdated)\n            this.updateValueAndValidity({ onlySelf: true });\n        return subtreeUpdated;\n    }\n    /** @internal */\n    _throwIfControlMissing(index) {\n        if (!this.controls.length) {\n            throw new Error(`\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n        }\n        if (!this.at(index)) {\n            throw new Error(`Cannot find form control at index ${index}`);\n        }\n    }\n    /** @internal */\n    _forEachChild(cb) {\n        this.controls.forEach((c, index) => {\n            cb(c, index);\n        });\n    }\n    /** @internal */\n    _updateValue() {\n        this.value = this.controls.filter((control) => control.enabled || this.disabled)\n            .map((control) => control.value);\n    }\n    /** @internal */\n    _anyControls(condition) {\n        return this.controls.some((control) => control.enabled && condition(control));\n    }\n    /** @internal */\n    _setUpControls() {\n        this._forEachChild((control) => this._registerControl(control));\n    }\n    /** @internal */\n    _checkAllValuesPresent(value) {\n        this._forEachChild((_, i) => {\n            if (value[i] === undefined) {\n                throw new Error(`Must supply a value for form control at index: ${i}.`);\n            }\n        });\n    }\n    /** @internal */\n    _allControlsDisabled() {\n        for (const control of this.controls) {\n            if (control.enabled)\n                return false;\n        }\n        return this.controls.length > 0 || this.disabled;\n    }\n    _registerControl(control) {\n        control.setParent(this);\n        control._registerOnCollectionChange(this._onCollectionChange);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
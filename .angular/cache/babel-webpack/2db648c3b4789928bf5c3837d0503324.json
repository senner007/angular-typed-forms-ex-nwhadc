{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken, ɵisObservable as isObservable, ɵisPromise as isPromise } from '@angular/core';\nimport { forkJoin, from } from 'rxjs';\nimport { map } from 'rxjs/operators';\nconst ngDevMode = true;\n\nfunction isEmptyInputValue(value) {\n  // we don't check for string here so it also works with arrays\n  return value == null || value.length === 0;\n}\n\nfunction hasValidLength(value) {\n  // non-strict comparison is intentional, to check for both `null` and `undefined` values\n  return value != null && typeof value.length === 'number';\n}\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_ASYNC_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n * @publicApi\n */\n\n\nexport const NG_VALIDATORS = new InjectionToken('NgValidators');\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Promise<ValidationErrors|null> {\n *     return Promise.resolve({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\n\nexport const NG_ASYNC_VALIDATORS = new InjectionToken('NgAsyncValidators');\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\n\nconst EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](/guide/form-validation)\n *\n * @publicApi\n */\n\nexport class Validators {\n  /**\n   * @description\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```typescript\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n  static min(min) {\n    return minValidator(min);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```typescript\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static max(max) {\n    return maxValidator(max);\n  }\n  /**\n   * @description\n   * Validator that requires the control have a non-empty value.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static required(control) {\n    return requiredValidator(control);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field value is true\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static requiredTrue(control) {\n    return requiredTrueValidator(control);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * Tests the value using a [regular\n   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n   * pattern suitable for common usecases. The pattern is based on the definition of a valid email\n   * address in the [WHATWG HTML\n   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n   * lengths of different parts of the address).\n   *\n   * The differences from the WHATWG version include:\n   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n   * - Disallow `local-part` to be longer than 64 characters.\n   * - Disallow the whole address to be longer than 254 characters.\n   *\n   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n   * validate the value against a different pattern.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```typescript\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static email(control) {\n    return emailValidator(control);\n  }\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use the\n   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n   * only for types that have a numeric `length` property, such as strings or arrays. The\n   * `minLength` validator logic is also not invoked for values when their `length` property is 0\n   * (for example in case of an empty string or an empty array), to support optional controls. You\n   * can use the standard `required` validator if empty values should not be considered valid.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```typescript\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static minLength(minLength) {\n    return minLengthValidator(minLength);\n  }\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use the\n   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n   * only for types that have a numeric `length` property, such as strings or arrays.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```typescript\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static maxLength(maxLength) {\n    return maxLengthValidator(maxLength);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided by default if you use the HTML5 `pattern` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```typescript\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * ### Pattern matching with the global or sticky flag\n   *\n   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n   * can produce different results on the same input when validations are run consecutively. This is\n   * due to how the behavior of `RegExp.prototype.test` is\n   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n   * Due to this behavior, it is recommended that when using\n   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n   * flag enabled.\n   *\n   * ```typescript\n   * // Not recommended (since the `g` flag is used)\n   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n   *\n   * // Good\n   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n   * ```\n   *\n   * @param pattern A regular expression to be used as is to test the values, or a string.\n   * If a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static pattern(pattern) {\n    return patternValidator(pattern);\n  }\n  /**\n   * @description\n   * Validator that performs no operation.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static nullValidator(control) {\n    return nullValidator(control);\n  }\n\n  static compose(validators) {\n    return compose(validators);\n  }\n  /**\n   * @description\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   *\n   * @see `updateValueAndValidity()`\n   *\n   */\n\n\n  static composeAsync(validators) {\n    return composeAsync(validators);\n  }\n\n}\n/**\n * Validator that requires the control's value to be greater than or equal to the provided number.\n * See `Validators.min` for additional information.\n */\n\nexport function minValidator(min) {\n  return control => {\n    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n      return null; // don't validate empty values to allow optional controls\n    }\n\n    const value = parseFloat(control.value); // Controls with NaN values after parsing should be treated as not having a\n    // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n\n    return !isNaN(value) && value < min ? {\n      min: {\n        min: min,\n        actual: control.value\n      }\n    } : null;\n  };\n}\n/**\n * Validator that requires the control's value to be less than or equal to the provided number.\n * See `Validators.max` for additional information.\n */\n\nexport function maxValidator(max) {\n  return control => {\n    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n      return null; // don't validate empty values to allow optional controls\n    }\n\n    const value = parseFloat(control.value); // Controls with NaN values after parsing should be treated as not having a\n    // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n\n    return !isNaN(value) && value > max ? {\n      max: {\n        max: max,\n        actual: control.value\n      }\n    } : null;\n  };\n}\n/**\n * Validator that requires the control have a non-empty value.\n * See `Validators.required` for additional information.\n */\n\nexport function requiredValidator(control) {\n  return isEmptyInputValue(control.value) ? {\n    required: true\n  } : null;\n}\n/**\n * Validator that requires the control's value be true. This validator is commonly\n * used for required checkboxes.\n * See `Validators.requiredTrue` for additional information.\n */\n\nexport function requiredTrueValidator(control) {\n  return control.value === true ? null : {\n    required: true\n  };\n}\n/**\n * Validator that requires the control's value pass an email validation test.\n * See `Validators.email` for additional information.\n */\n\nexport function emailValidator(control) {\n  if (isEmptyInputValue(control.value)) {\n    return null; // don't validate empty values to allow optional controls\n  }\n\n  return EMAIL_REGEXP.test(control.value) ? null : {\n    email: true\n  };\n}\n/**\n * Validator that requires the length of the control's value to be greater than or equal\n * to the provided minimum length. See `Validators.minLength` for additional information.\n */\n\nexport function minLengthValidator(minLength) {\n  return control => {\n    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {\n      // don't validate empty values to allow optional controls\n      // don't validate values without `length` property\n      return null;\n    }\n\n    return control.value.length < minLength ? {\n      minlength: {\n        requiredLength: minLength,\n        actualLength: control.value.length\n      }\n    } : null;\n  };\n}\n/**\n * Validator that requires the length of the control's value to be less than or equal\n * to the provided maximum length. See `Validators.maxLength` for additional information.\n */\n\nexport function maxLengthValidator(maxLength) {\n  return control => {\n    return hasValidLength(control.value) && control.value.length > maxLength ? {\n      maxlength: {\n        requiredLength: maxLength,\n        actualLength: control.value.length\n      }\n    } : null;\n  };\n}\n/**\n * Validator that requires the control's value to match a regex pattern.\n * See `Validators.pattern` for additional information.\n */\n\nexport function patternValidator(pattern) {\n  if (!pattern) return nullValidator;\n  let regex;\n  let regexStr;\n\n  if (typeof pattern === 'string') {\n    regexStr = '';\n    if (pattern.charAt(0) !== '^') regexStr += '^';\n    regexStr += pattern;\n    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n    regex = new RegExp(regexStr);\n  } else {\n    regexStr = pattern.toString();\n    regex = pattern;\n  }\n\n  return control => {\n    if (isEmptyInputValue(control.value)) {\n      return null; // don't validate empty values to allow optional controls\n    }\n\n    const value = control.value;\n    return regex.test(value) ? null : {\n      pattern: {\n        requiredPattern: regexStr,\n        actualValue: value\n      }\n    };\n  };\n}\n/**\n * Function that has `ValidatorFn` shape, but performs no operation.\n */\n\nexport function nullValidator(control) {\n  return null;\n}\n\nfunction isPresent(o) {\n  return o != null;\n}\n\nexport function toObservable(r) {\n  const obs = isPromise(r) ? from(r) : r;\n\n  if (!isObservable(obs) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n    throw new Error(`Expected validator to return Promise or Observable.`);\n  }\n\n  return obs;\n}\n\nfunction mergeErrors(arrayOfErrors) {\n  let res = {}; // Not using Array.reduce here due to a Chrome 80 bug\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n\n  arrayOfErrors.forEach(errors => {\n    res = errors != null ? Object.assign(Object.assign({}, res), errors) : res;\n  });\n  return Object.keys(res).length === 0 ? null : res;\n}\n\nfunction executeValidators(control, validators) {\n  return validators.map(validator => validator(control));\n}\n\nfunction isValidatorFn(validator) {\n  return !validator.validate;\n}\n/**\n * Given the list of validators that may contain both functions as well as classes, return the list\n * of validator functions (convert validator classes into validator functions). This is needed to\n * have consistent structure in validators list before composing them.\n *\n * @param validators The set of validators that may contain validators both in plain function form\n *     as well as represented as a validator class.\n */\n\n\nexport function normalizeValidators(validators) {\n  return validators.map(validator => {\n    return isValidatorFn(validator) ? validator : c => validator.validate(c);\n  });\n}\n/**\n * Merges synchronous validators into a single validator function.\n * See `Validators.compose` for additional information.\n */\n\nfunction compose(validators) {\n  if (!validators) return null;\n  const presentValidators = validators.filter(isPresent);\n  if (presentValidators.length == 0) return null;\n  return function (control) {\n    return mergeErrors(executeValidators(control, presentValidators));\n  };\n}\n/**\n * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),\n * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single\n * validator function.\n */\n\n\nexport function composeValidators(validators) {\n  return validators != null ? compose(normalizeValidators(validators)) : null;\n}\n/**\n * Merges asynchronous validators into a single validator function.\n * See `Validators.composeAsync` for additional information.\n */\n\nfunction composeAsync(validators) {\n  if (!validators) return null;\n  const presentValidators = validators.filter(isPresent);\n  if (presentValidators.length == 0) return null;\n  return function (control) {\n    const observables = executeValidators(control, presentValidators).map(toObservable);\n    return forkJoin(observables).pipe(map(mergeErrors));\n  };\n}\n/**\n * Accepts a list of async validators of different possible shapes (`AsyncValidator` and\n * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges\n * them into a single validator function.\n */\n\n\nexport function composeAsyncValidators(validators) {\n  return validators != null ? composeAsync(normalizeValidators(validators)) : null;\n}\n/**\n * Merges raw control validators with a given directive validator and returns the combined list of\n * validators as an array.\n */\n\nexport function mergeValidators(controlValidators, dirValidator) {\n  if (controlValidators === null) return [dirValidator];\n  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];\n}\n/**\n * Retrieves the list of raw synchronous validators attached to a given control.\n */\n\nexport function getControlValidators(control) {\n  return control._rawValidators;\n}\n/**\n * Retrieves the list of raw asynchronous validators attached to a given control.\n */\n\nexport function getControlAsyncValidators(control) {\n  return control._rawAsyncValidators;\n}\n/**\n * Accepts a singleton validator, an array, or null, and returns an array type with the provided\n * validators.\n *\n * @param validators A validator, validators, or null.\n * @returns A validators array.\n */\n\nexport function makeValidatorsArray(validators) {\n  if (!validators) return [];\n  return Array.isArray(validators) ? validators : [validators];\n}\n/**\n * Determines whether a validator or validators array has a given validator.\n *\n * @param validators The validator or validators to compare against.\n * @param validator The validator to check.\n * @returns Whether the validator is present.\n */\n\nexport function hasValidator(validators, validator) {\n  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;\n}\n/**\n * Combines two arrays of validators into one. If duplicates are provided, only one will be added.\n *\n * @param validators The new validators.\n * @param currentValidators The base array of currrent validators.\n * @returns An array of validators.\n */\n\nexport function addValidators(validators, currentValidators) {\n  const current = makeValidatorsArray(currentValidators);\n  const validatorsToAdd = makeValidatorsArray(validators);\n  validatorsToAdd.forEach(v => {\n    // Note: if there are duplicate entries in the new validators array,\n    // only the first one would be added to the current list of validarors.\n    // Duplicate ones would be ignored since `hasValidator` would detect\n    // the presence of a validator function and we update the current list in place.\n    if (!hasValidator(current, v)) {\n      current.push(v);\n    }\n  });\n  return current;\n}\nexport function removeValidators(validators, currentValidators) {\n  return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));\n}","map":{"version":3,"sources":["/home/nig/angular-typed-forms-ex-nwhadc/src/forms/src/validators.ts"],"names":["InjectionToken","ɵisObservable","isObservable","ɵisPromise","isPromise","forkJoin","from","map","ngDevMode","isEmptyInputValue","value","length","hasValidLength","NG_VALIDATORS","NG_ASYNC_VALIDATORS","EMAIL_REGEXP","Validators","min","minValidator","max","maxValidator","required","control","requiredValidator","requiredTrue","requiredTrueValidator","email","emailValidator","minLength","minLengthValidator","maxLength","maxLengthValidator","pattern","patternValidator","nullValidator","compose","validators","composeAsync","parseFloat","isNaN","actual","test","minlength","requiredLength","actualLength","maxlength","regex","regexStr","charAt","RegExp","toString","requiredPattern","actualValue","isPresent","o","toObservable","r","obs","Error","mergeErrors","arrayOfErrors","res","forEach","errors","Object","assign","keys","executeValidators","validator","isValidatorFn","validate","normalizeValidators","c","presentValidators","filter","composeValidators","observables","pipe","composeAsyncValidators","mergeValidators","controlValidators","dirValidator","Array","isArray","getControlValidators","_rawValidators","getControlAsyncValidators","_rawAsyncValidators","makeValidatorsArray","hasValidator","includes","addValidators","currentValidators","current","validatorsToAdd","v","push","removeValidators"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAT,EAAyBC,aAAa,IAAIC,YAA1C,EAAwDC,UAAU,IAAIC,SAAtE,QAAwF,eAAxF;AACA,SAASC,QAAT,EAAmBC,IAAnB,QAA+B,MAA/B;AACA,SAASC,GAAT,QAAoB,gBAApB;AACA,MAAMC,SAAS,GAAG,IAAlB;;AACA,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAC9B;AACA,SAAOA,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACC,MAAN,KAAiB,CAAzC;AACH;;AACD,SAASC,cAAT,CAAwBF,KAAxB,EAA+B;AAC3B;AACA,SAAOA,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAK,CAACC,MAAb,KAAwB,QAAhD;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,aAAa,GAAG,IAAIb,cAAJ,CAAmB,cAAnB,CAAtB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMc,mBAAmB,GAAG,IAAId,cAAJ,CAAmB,mBAAnB,CAA5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMe,YAAY,GAAG,oMAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,UAAN,CAAiB;AACpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACc,SAAHC,GAAG,CAACA,GAAD,EAAM;AACZ,WAAOC,YAAY,CAACD,GAAD,CAAnB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACc,SAAHE,GAAG,CAACA,GAAD,EAAM;AACZ,WAAOC,YAAY,CAACD,GAAD,CAAnB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,SAARE,QAAQ,CAACC,OAAD,EAAU;AACrB,WAAOC,iBAAiB,CAACD,OAAD,CAAxB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACuB,SAAZE,YAAY,CAACF,OAAD,EAAU;AACzB,WAAOG,qBAAqB,CAACH,OAAD,CAA5B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,SAALI,KAAK,CAACJ,OAAD,EAAU;AAClB,WAAOK,cAAc,CAACL,OAAD,CAArB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,SAATM,SAAS,CAACA,SAAD,EAAY;AACxB,WAAOC,kBAAkB,CAACD,SAAD,CAAzB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken, ɵisObservable as isObservable, ɵisPromise as isPromise, } from '@angular/core';\nimport { forkJoin, from } from 'rxjs';\nimport { map } from 'rxjs/operators';\nconst ngDevMode = true;\nfunction isEmptyInputValue(value) {\n    // we don't check for string here so it also works with arrays\n    return value == null || value.length === 0;\n}\nfunction hasValidLength(value) {\n    // non-strict comparison is intentional, to check for both `null` and `undefined` values\n    return value != null && typeof value.length === 'number';\n}\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_ASYNC_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport const NG_VALIDATORS = new InjectionToken('NgValidators');\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with\n * `AbstractControl`s.\n *\n * @see `NG_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Provide a custom async validator directive\n *\n * The following example implements the `AsyncValidator` interface to create an\n * async validator directive with a custom error key.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customAsyncValidator]',\n *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:\n * true}]\n * })\n * class CustomAsyncValidatorDirective implements AsyncValidator {\n *   validate(control: AbstractControl): Promise<ValidationErrors|null> {\n *     return Promise.resolve({'custom': true});\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport const NG_ASYNC_VALIDATORS = new InjectionToken('NgAsyncValidators');\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\nconst EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](/guide/form-validation)\n *\n * @publicApi\n */\nexport class Validators {\n    /**\n     * @description\n     * Validator that requires the control's value to be greater than or equal to the provided number.\n     *\n     * @usageNotes\n     *\n     * ### Validate against a minimum of 3\n     *\n     * ```typescript\n     * const control = new FormControl(2, Validators.min(3));\n     *\n     * console.log(control.errors); // {min: {min: 3, actual: 2}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `min` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static min(min) {\n        return minValidator(min);\n    }\n    /**\n     * @description\n     * Validator that requires the control's value to be less than or equal to the provided number.\n     *\n     * @usageNotes\n     *\n     * ### Validate against a maximum of 15\n     *\n     * ```typescript\n     * const control = new FormControl(16, Validators.max(15));\n     *\n     * console.log(control.errors); // {max: {max: 15, actual: 16}}\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `max` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static max(max) {\n        return maxValidator(max);\n    }\n    /**\n     * @description\n     * Validator that requires the control have a non-empty value.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field is non-empty\n     *\n     * ```typescript\n     * const control = new FormControl('', Validators.required);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map with the `required` property\n     * if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static required(control) {\n        return requiredValidator(control);\n    }\n    /**\n     * @description\n     * Validator that requires the control's value be true. This validator is commonly\n     * used for required checkboxes.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field value is true\n     *\n     * ```typescript\n     * const control = new FormControl('', Validators.requiredTrue);\n     *\n     * console.log(control.errors); // {required: true}\n     * ```\n     *\n     * @returns An error map that contains the `required` property\n     * set to `true` if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static requiredTrue(control) {\n        return requiredTrueValidator(control);\n    }\n    /**\n     * @description\n     * Validator that requires the control's value pass an email validation test.\n     *\n     * Tests the value using a [regular\n     * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n     * pattern suitable for common usecases. The pattern is based on the definition of a valid email\n     * address in the [WHATWG HTML\n     * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n     * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n     * lengths of different parts of the address).\n     *\n     * The differences from the WHATWG version include:\n     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n     * - Disallow `local-part` to be longer than 64 characters.\n     * - Disallow the whole address to be longer than 254 characters.\n     *\n     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n     * validate the value against a different pattern.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field matches a valid email pattern\n     *\n     * ```typescript\n     * const control = new FormControl('bad@', Validators.email);\n     *\n     * console.log(control.errors); // {email: true}\n     * ```\n     *\n     * @returns An error map with the `email` property\n     * if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static email(control) {\n        return emailValidator(control);\n    }\n    /**\n     * @description\n     * Validator that requires the length of the control's value to be greater than or equal\n     * to the provided minimum length. This validator is also provided by default if you use the\n     * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n     * only for types that have a numeric `length` property, such as strings or arrays. The\n     * `minLength` validator logic is also not invoked for values when their `length` property is 0\n     * (for example in case of an empty string or an empty array), to support optional controls. You\n     * can use the standard `required` validator if empty values should not be considered valid.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field has a minimum of 3 characters\n     *\n     * ```typescript\n     * const control = new FormControl('ng', Validators.minLength(3));\n     *\n     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n     * ```\n     *\n     * ```html\n     * <input minlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `minlength` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static minLength(minLength) {\n        return minLengthValidator(minLength);\n    }\n    /**\n     * @description\n     * Validator that requires the length of the control's value to be less than or equal\n     * to the provided maximum length. This validator is also provided by default if you use the\n     * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n     * only for types that have a numeric `length` property, such as strings or arrays.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field has maximum of 5 characters\n     *\n     * ```typescript\n     * const control = new FormControl('Angular', Validators.maxLength(5));\n     *\n     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n     * ```\n     *\n     * ```html\n     * <input maxlength=\"5\">\n     * ```\n     *\n     * @returns A validator function that returns an error map with the\n     * `maxlength` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static maxLength(maxLength) {\n        return maxLengthValidator(maxLength);\n    }\n    /**\n     * @description\n     * Validator that requires the control's value to match a regex pattern. This validator is also\n     * provided by default if you use the HTML5 `pattern` attribute.\n     *\n     * @usageNotes\n     *\n     * ### Validate that the field only contains letters or spaces\n     *\n     * ```typescript\n     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n     *\n     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n     * ```\n     *\n     * ```html\n     * <input pattern=\"[a-zA-Z ]*\">\n     * ```\n     *\n     * ### Pattern matching with the global or sticky flag\n     *\n     * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n     * can produce different results on the same input when validations are run consecutively. This is\n     * due to how the behavior of `RegExp.prototype.test` is\n     * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n     * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n     * Due to this behavior, it is recommended that when using\n     * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n     * flag enabled.\n     *\n     * ```typescript\n     * // Not recommended (since the `g` flag is used)\n     * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n     *\n     * // Good\n     * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n     * ```\n     *\n     * @param pattern A regular expression to be used as is to test the values, or a string.\n     * If a string is passed, the `^` character is prepended and the `$` character is\n     * appended to the provided string (if not already present), and the resulting regular\n     * expression is used to test the values.\n     *\n     * @returns A validator function that returns an error map with the\n     * `pattern` property if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static pattern(pattern) {\n        return patternValidator(pattern);\n    }\n    /**\n     * @description\n     * Validator that performs no operation.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static nullValidator(control) {\n        return nullValidator(control);\n    }\n    static compose(validators) {\n        return compose(validators);\n    }\n    /**\n     * @description\n     * Compose multiple async validators into a single function that returns the union\n     * of the individual error objects for the provided control.\n     *\n     * @returns A validator function that returns an error map with the\n     * merged error objects of the async validators if the validation check fails, otherwise `null`.\n     *\n     * @see `updateValueAndValidity()`\n     *\n     */\n    static composeAsync(validators) {\n        return composeAsync(validators);\n    }\n}\n/**\n * Validator that requires the control's value to be greater than or equal to the provided number.\n * See `Validators.min` for additional information.\n */\nexport function minValidator(min) {\n    return (control) => {\n        if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n            return null; // don't validate empty values to allow optional controls\n        }\n        const value = parseFloat(control.value);\n        // Controls with NaN values after parsing should be treated as not having a\n        // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n        return !isNaN(value) && value < min\n            ? { min: { min: min, actual: control.value } }\n            : null;\n    };\n}\n/**\n * Validator that requires the control's value to be less than or equal to the provided number.\n * See `Validators.max` for additional information.\n */\nexport function maxValidator(max) {\n    return (control) => {\n        if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n            return null; // don't validate empty values to allow optional controls\n        }\n        const value = parseFloat(control.value);\n        // Controls with NaN values after parsing should be treated as not having a\n        // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n        return !isNaN(value) && value > max\n            ? { max: { max: max, actual: control.value } }\n            : null;\n    };\n}\n/**\n * Validator that requires the control have a non-empty value.\n * See `Validators.required` for additional information.\n */\nexport function requiredValidator(control) {\n    return isEmptyInputValue(control.value) ? { required: true } : null;\n}\n/**\n * Validator that requires the control's value be true. This validator is commonly\n * used for required checkboxes.\n * See `Validators.requiredTrue` for additional information.\n */\nexport function requiredTrueValidator(control) {\n    return control.value === true ? null : { required: true };\n}\n/**\n * Validator that requires the control's value pass an email validation test.\n * See `Validators.email` for additional information.\n */\nexport function emailValidator(control) {\n    if (isEmptyInputValue(control.value)) {\n        return null; // don't validate empty values to allow optional controls\n    }\n    return EMAIL_REGEXP.test(control.value) ? null : { email: true };\n}\n/**\n * Validator that requires the length of the control's value to be greater than or equal\n * to the provided minimum length. See `Validators.minLength` for additional information.\n */\nexport function minLengthValidator(minLength) {\n    return (control) => {\n        if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {\n            // don't validate empty values to allow optional controls\n            // don't validate values without `length` property\n            return null;\n        }\n        return control.value.length < minLength\n            ? {\n                minlength: {\n                    requiredLength: minLength,\n                    actualLength: control.value.length,\n                },\n            }\n            : null;\n    };\n}\n/**\n * Validator that requires the length of the control's value to be less than or equal\n * to the provided maximum length. See `Validators.maxLength` for additional information.\n */\nexport function maxLengthValidator(maxLength) {\n    return (control) => {\n        return hasValidLength(control.value) && control.value.length > maxLength\n            ? {\n                maxlength: {\n                    requiredLength: maxLength,\n                    actualLength: control.value.length,\n                },\n            }\n            : null;\n    };\n}\n/**\n * Validator that requires the control's value to match a regex pattern.\n * See `Validators.pattern` for additional information.\n */\nexport function patternValidator(pattern) {\n    if (!pattern)\n        return nullValidator;\n    let regex;\n    let regexStr;\n    if (typeof pattern === 'string') {\n        regexStr = '';\n        if (pattern.charAt(0) !== '^')\n            regexStr += '^';\n        regexStr += pattern;\n        if (pattern.charAt(pattern.length - 1) !== '$')\n            regexStr += '$';\n        regex = new RegExp(regexStr);\n    }\n    else {\n        regexStr = pattern.toString();\n        regex = pattern;\n    }\n    return (control) => {\n        if (isEmptyInputValue(control.value)) {\n            return null; // don't validate empty values to allow optional controls\n        }\n        const value = control.value;\n        return regex.test(value)\n            ? null\n            : { pattern: { requiredPattern: regexStr, actualValue: value } };\n    };\n}\n/**\n * Function that has `ValidatorFn` shape, but performs no operation.\n */\nexport function nullValidator(control) {\n    return null;\n}\nfunction isPresent(o) {\n    return o != null;\n}\nexport function toObservable(r) {\n    const obs = isPromise(r) ? from(r) : r;\n    if (!isObservable(obs) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw new Error(`Expected validator to return Promise or Observable.`);\n    }\n    return obs;\n}\nfunction mergeErrors(arrayOfErrors) {\n    let res = {};\n    // Not using Array.reduce here due to a Chrome 80 bug\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\n    arrayOfErrors.forEach((errors) => {\n        res = errors != null ? Object.assign(Object.assign({}, res), errors) : res;\n    });\n    return Object.keys(res).length === 0 ? null : res;\n}\nfunction executeValidators(control, validators) {\n    return validators.map((validator) => validator(control));\n}\nfunction isValidatorFn(validator) {\n    return !validator.validate;\n}\n/**\n * Given the list of validators that may contain both functions as well as classes, return the list\n * of validator functions (convert validator classes into validator functions). This is needed to\n * have consistent structure in validators list before composing them.\n *\n * @param validators The set of validators that may contain validators both in plain function form\n *     as well as represented as a validator class.\n */\nexport function normalizeValidators(validators) {\n    return validators.map((validator) => {\n        return isValidatorFn(validator)\n            ? validator\n            : ((c) => validator.validate(c));\n    });\n}\n/**\n * Merges synchronous validators into a single validator function.\n * See `Validators.compose` for additional information.\n */\nfunction compose(validators) {\n    if (!validators)\n        return null;\n    const presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0)\n        return null;\n    return function (control) {\n        return mergeErrors(executeValidators(control, presentValidators));\n    };\n}\n/**\n * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),\n * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single\n * validator function.\n */\nexport function composeValidators(validators) {\n    return validators != null\n        ? compose(normalizeValidators(validators))\n        : null;\n}\n/**\n * Merges asynchronous validators into a single validator function.\n * See `Validators.composeAsync` for additional information.\n */\nfunction composeAsync(validators) {\n    if (!validators)\n        return null;\n    const presentValidators = validators.filter(isPresent);\n    if (presentValidators.length == 0)\n        return null;\n    return function (control) {\n        const observables = executeValidators(control, presentValidators).map(toObservable);\n        return forkJoin(observables).pipe(map(mergeErrors));\n    };\n}\n/**\n * Accepts a list of async validators of different possible shapes (`AsyncValidator` and\n * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges\n * them into a single validator function.\n */\nexport function composeAsyncValidators(validators) {\n    return validators != null\n        ? composeAsync(normalizeValidators(validators))\n        : null;\n}\n/**\n * Merges raw control validators with a given directive validator and returns the combined list of\n * validators as an array.\n */\nexport function mergeValidators(controlValidators, dirValidator) {\n    if (controlValidators === null)\n        return [dirValidator];\n    return Array.isArray(controlValidators)\n        ? [...controlValidators, dirValidator]\n        : [controlValidators, dirValidator];\n}\n/**\n * Retrieves the list of raw synchronous validators attached to a given control.\n */\nexport function getControlValidators(control) {\n    return control._rawValidators;\n}\n/**\n * Retrieves the list of raw asynchronous validators attached to a given control.\n */\nexport function getControlAsyncValidators(control) {\n    return control._rawAsyncValidators;\n}\n/**\n * Accepts a singleton validator, an array, or null, and returns an array type with the provided\n * validators.\n *\n * @param validators A validator, validators, or null.\n * @returns A validators array.\n */\nexport function makeValidatorsArray(validators) {\n    if (!validators)\n        return [];\n    return Array.isArray(validators) ? validators : [validators];\n}\n/**\n * Determines whether a validator or validators array has a given validator.\n *\n * @param validators The validator or validators to compare against.\n * @param validator The validator to check.\n * @returns Whether the validator is present.\n */\nexport function hasValidator(validators, validator) {\n    return Array.isArray(validators)\n        ? validators.includes(validator)\n        : validators === validator;\n}\n/**\n * Combines two arrays of validators into one. If duplicates are provided, only one will be added.\n *\n * @param validators The new validators.\n * @param currentValidators The base array of currrent validators.\n * @returns An array of validators.\n */\nexport function addValidators(validators, currentValidators) {\n    const current = makeValidatorsArray(currentValidators);\n    const validatorsToAdd = makeValidatorsArray(validators);\n    validatorsToAdd.forEach((v) => {\n        // Note: if there are duplicate entries in the new validators array,\n        // only the first one would be added to the current list of validarors.\n        // Duplicate ones would be ignored since `hasValidator` would detect\n        // the presence of a validator function and we update the current list in place.\n        if (!hasValidator(current, v)) {\n            current.push(v);\n        }\n    });\n    return current;\n}\nexport function removeValidators(validators, currentValidators) {\n    return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));\n}\n"]},"metadata":{},"sourceType":"module"}
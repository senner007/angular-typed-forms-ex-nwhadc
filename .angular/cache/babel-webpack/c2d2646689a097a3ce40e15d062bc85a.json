{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { composeAsyncValidators, composeValidators } from '../validators';\n/**\n * @description\n * Base class for control directives.\n *\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\n *\n * @publicApi\n */\n\nexport class AbstractControlDirective {\n  constructor() {\n    /**\n     * Set of synchronous validators as they were provided while calling `setValidators` function.\n     * @internal\n     */\n    this._rawValidators = [];\n    /**\n     * Set of asynchronous validators as they were provided while calling `setAsyncValidators`\n     * function.\n     * @internal\n     */\n\n    this._rawAsyncValidators = [];\n    /*\n     * The set of callbacks to be invoked when directive instance is being destroyed.\n     */\n\n    this._onDestroyCallbacks = [];\n  }\n  /**\n   * @description\n   * Reports the value of the control if it is present, otherwise null.\n   */\n\n\n  get value() {\n    return this.control ? this.control.value : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is valid. A control is considered valid if no\n   * validation errors exist with the current value.\n   * If the control is not present, null is returned.\n   */\n\n\n  get valid() {\n    return this.control ? this.control.valid : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is invalid, meaning that an error exists in the input value.\n   * If the control is not present, null is returned.\n   */\n\n\n  get invalid() {\n    return this.control ? this.control.invalid : null;\n  }\n  /**\n   * @description\n   * Reports whether a control is pending, meaning that that async validation is occurring and\n   * errors are not yet available for the input value. If the control is not present, null is\n   * returned.\n   */\n\n\n  get pending() {\n    return this.control ? this.control.pending : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is disabled, meaning that the control is disabled\n   * in the UI and is exempt from validation checks and excluded from aggregate\n   * values of ancestor controls. If the control is not present, null is returned.\n   */\n\n\n  get disabled() {\n    return this.control ? this.control.disabled : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is enabled, meaning that the control is included in ancestor\n   * calculations of validity or value. If the control is not present, null is returned.\n   */\n\n\n  get enabled() {\n    return this.control ? this.control.enabled : null;\n  }\n  /**\n   * @description\n   * Reports the control's validation errors. If the control is not present, null is returned.\n   */\n\n\n  get errors() {\n    return this.control ? this.control.errors : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is pristine, meaning that the user has not yet changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n\n\n  get pristine() {\n    return this.control ? this.control.pristine : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is dirty, meaning that the user has changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n\n\n  get dirty() {\n    return this.control ? this.control.dirty : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is touched, meaning that the user has triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n\n\n  get touched() {\n    return this.control ? this.control.touched : null;\n  }\n  /**\n   * @description\n   * Reports the validation status of the control. Possible values include:\n   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\n   * If the control is not present, null is returned.\n   */\n\n\n  get status() {\n    return this.control ? this.control.status : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is untouched, meaning that the user has not yet triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n\n\n  get untouched() {\n    return this.control ? this.control.untouched : null;\n  }\n  /**\n   * @description\n   * Returns a multicasting observable that emits a validation status whenever it is\n   * calculated for the control. If the control is not present, null is returned.\n   */\n\n\n  get statusChanges() {\n    return this.control ? this.control.statusChanges : null;\n  }\n  /**\n   * @description\n   * Returns a multicasting observable of value changes for the control that emits every time the\n   * value of the control changes in the UI or programmatically.\n   * If the control is not present, null is returned.\n   */\n\n\n  get valueChanges() {\n    return this.control ? this.control.valueChanges : null;\n  }\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n\n\n  get path() {\n    return null;\n  }\n  /**\n   * Sets synchronous validators for this directive.\n   * @internal\n   */\n\n\n  _setValidators(validators) {\n    this._rawValidators = validators || [];\n    this._composedValidatorFn = composeValidators(this._rawValidators);\n  }\n  /**\n   * Sets asynchronous validators for this directive.\n   * @internal\n   */\n\n\n  _setAsyncValidators(validators) {\n    this._rawAsyncValidators = validators || [];\n    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);\n  }\n  /**\n   * @description\n   * Synchronous validator function composed of all the synchronous validators registered with this\n   * directive.\n   */\n\n\n  get validator() {\n    return this._composedValidatorFn || null;\n  }\n  /**\n   * @description\n   * Asynchronous validator function composed of all the asynchronous validators registered with\n   * this directive.\n   */\n\n\n  get asyncValidator() {\n    return this._composedAsyncValidatorFn || null;\n  }\n  /**\n   * Internal function to register callbacks that should be invoked\n   * when directive instance is being destroyed.\n   * @internal\n   */\n\n\n  _registerOnDestroy(fn) {\n    this._onDestroyCallbacks.push(fn);\n  }\n  /**\n   * Internal function to invoke all registered \"on destroy\" callbacks.\n   * Note: calling this function also clears the list of callbacks.\n   * @internal\n   */\n\n\n  _invokeOnDestroyCallbacks() {\n    this._onDestroyCallbacks.forEach(fn => fn());\n\n    this._onDestroyCallbacks = [];\n  }\n  /**\n   * @description\n   * Resets the control with the provided value if the control is present.\n   */\n\n\n  reset(value = undefined) {\n    if (this.control) this.control.reset(value);\n  }\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n\n\n  hasError(errorCode, path) {\n    return this.control ? this.control.hasError(errorCode, path) : false;\n  }\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n\n\n  getError(errorCode, path) {\n    return this.control ? this.control.getError(errorCode, path) : null;\n  }\n\n}","map":{"version":3,"sources":["/home/nig/angular-typed-forms-ex-nwhadc/src/forms/src/directives/abstract_control_directive.ts"],"names":["composeAsyncValidators","composeValidators","AbstractControlDirective","constructor","_rawValidators","_rawAsyncValidators","_onDestroyCallbacks","value","control","valid","invalid","pending","disabled","enabled","errors","pristine","dirty","touched","status","untouched","statusChanges","valueChanges","path","_setValidators","validators","_composedValidatorFn","_setAsyncValidators","_composedAsyncValidatorFn","validator","asyncValidator","_registerOnDestroy","fn","push","_invokeOnDestroyCallbacks","forEach","reset","undefined","hasError","errorCode","getError"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { composeAsyncValidators, composeValidators } from '../validators';\n/**\n * @description\n * Base class for control directives.\n *\n * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.\n *\n * @publicApi\n */\nexport class AbstractControlDirective {\n    constructor() {\n        /**\n         * Set of synchronous validators as they were provided while calling `setValidators` function.\n         * @internal\n         */\n        this._rawValidators = [];\n        /**\n         * Set of asynchronous validators as they were provided while calling `setAsyncValidators`\n         * function.\n         * @internal\n         */\n        this._rawAsyncValidators = [];\n        /*\n         * The set of callbacks to be invoked when directive instance is being destroyed.\n         */\n        this._onDestroyCallbacks = [];\n    }\n    /**\n     * @description\n     * Reports the value of the control if it is present, otherwise null.\n     */\n    get value() {\n        return this.control ? this.control.value : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is valid. A control is considered valid if no\n     * validation errors exist with the current value.\n     * If the control is not present, null is returned.\n     */\n    get valid() {\n        return this.control ? this.control.valid : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is invalid, meaning that an error exists in the input value.\n     * If the control is not present, null is returned.\n     */\n    get invalid() {\n        return this.control ? this.control.invalid : null;\n    }\n    /**\n     * @description\n     * Reports whether a control is pending, meaning that that async validation is occurring and\n     * errors are not yet available for the input value. If the control is not present, null is\n     * returned.\n     */\n    get pending() {\n        return this.control ? this.control.pending : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is disabled, meaning that the control is disabled\n     * in the UI and is exempt from validation checks and excluded from aggregate\n     * values of ancestor controls. If the control is not present, null is returned.\n     */\n    get disabled() {\n        return this.control ? this.control.disabled : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is enabled, meaning that the control is included in ancestor\n     * calculations of validity or value. If the control is not present, null is returned.\n     */\n    get enabled() {\n        return this.control ? this.control.enabled : null;\n    }\n    /**\n     * @description\n     * Reports the control's validation errors. If the control is not present, null is returned.\n     */\n    get errors() {\n        return this.control ? this.control.errors : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is pristine, meaning that the user has not yet changed\n     * the value in the UI. If the control is not present, null is returned.\n     */\n    get pristine() {\n        return this.control ? this.control.pristine : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is dirty, meaning that the user has changed\n     * the value in the UI. If the control is not present, null is returned.\n     */\n    get dirty() {\n        return this.control ? this.control.dirty : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is touched, meaning that the user has triggered\n     * a `blur` event on it. If the control is not present, null is returned.\n     */\n    get touched() {\n        return this.control ? this.control.touched : null;\n    }\n    /**\n     * @description\n     * Reports the validation status of the control. Possible values include:\n     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\n     * If the control is not present, null is returned.\n     */\n    get status() {\n        return this.control ? this.control.status : null;\n    }\n    /**\n     * @description\n     * Reports whether the control is untouched, meaning that the user has not yet triggered\n     * a `blur` event on it. If the control is not present, null is returned.\n     */\n    get untouched() {\n        return this.control ? this.control.untouched : null;\n    }\n    /**\n     * @description\n     * Returns a multicasting observable that emits a validation status whenever it is\n     * calculated for the control. If the control is not present, null is returned.\n     */\n    get statusChanges() {\n        return this.control ? this.control.statusChanges : null;\n    }\n    /**\n     * @description\n     * Returns a multicasting observable of value changes for the control that emits every time the\n     * value of the control changes in the UI or programmatically.\n     * If the control is not present, null is returned.\n     */\n    get valueChanges() {\n        return this.control ? this.control.valueChanges : null;\n    }\n    /**\n     * @description\n     * Returns an array that represents the path from the top-level form to this control.\n     * Each index is the string name of the control on that level.\n     */\n    get path() {\n        return null;\n    }\n    /**\n     * Sets synchronous validators for this directive.\n     * @internal\n     */\n    _setValidators(validators) {\n        this._rawValidators = validators || [];\n        this._composedValidatorFn = composeValidators(this._rawValidators);\n    }\n    /**\n     * Sets asynchronous validators for this directive.\n     * @internal\n     */\n    _setAsyncValidators(validators) {\n        this._rawAsyncValidators = validators || [];\n        this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);\n    }\n    /**\n     * @description\n     * Synchronous validator function composed of all the synchronous validators registered with this\n     * directive.\n     */\n    get validator() {\n        return this._composedValidatorFn || null;\n    }\n    /**\n     * @description\n     * Asynchronous validator function composed of all the asynchronous validators registered with\n     * this directive.\n     */\n    get asyncValidator() {\n        return this._composedAsyncValidatorFn || null;\n    }\n    /**\n     * Internal function to register callbacks that should be invoked\n     * when directive instance is being destroyed.\n     * @internal\n     */\n    _registerOnDestroy(fn) {\n        this._onDestroyCallbacks.push(fn);\n    }\n    /**\n     * Internal function to invoke all registered \"on destroy\" callbacks.\n     * Note: calling this function also clears the list of callbacks.\n     * @internal\n     */\n    _invokeOnDestroyCallbacks() {\n        this._onDestroyCallbacks.forEach(fn => fn());\n        this._onDestroyCallbacks = [];\n    }\n    /**\n     * @description\n     * Resets the control with the provided value if the control is present.\n     */\n    reset(value = undefined) {\n        if (this.control)\n            this.control.reset(value);\n    }\n    /**\n     * @description\n     * Reports whether the control with the given path has the error specified.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * If no path is given, this method checks for the error on the current control.\n     *\n     * @returns whether the given error is present in the control at the given path.\n     *\n     * If the control is not present, false is returned.\n     */\n    hasError(errorCode, path) {\n        return this.control ? this.control.hasError(errorCode, path) : false;\n    }\n    /**\n     * @description\n     * Reports error data for the control with the given path.\n     *\n     * @param errorCode The code of the error to check\n     * @param path A list of control names that designates how to move from the current control\n     * to the control that should be queried for errors.\n     *\n     * @usageNotes\n     * For example, for the following `FormGroup`:\n     *\n     * ```\n     * form = new FormGroup({\n     *   address: new FormGroup({ street: new FormControl() })\n     * });\n     * ```\n     *\n     * The path to the 'street' control from the root form would be 'address' -> 'street'.\n     *\n     * It can be provided to this method in one of two formats:\n     *\n     * 1. An array of string control names, e.g. `['address', 'street']`\n     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n     *\n     * @returns error data for that particular error. If the control or error is not present,\n     * null is returned.\n     */\n    getError(errorCode, path) {\n        return this.control ? this.control.getError(errorCode, path) : null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}